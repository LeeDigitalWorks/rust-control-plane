// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Certificates {
    #[prost(message, repeated, tag = "1")]
    pub certificates: ::prost::alloc::vec::Vec<Certificate>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Certificate {
    #[prost(message, repeated, tag = "1")]
    pub ca_cert: ::prost::alloc::vec::Vec<CertificateDetails>,
    #[prost(message, repeated, tag = "2")]
    pub cert_chain: ::prost::alloc::vec::Vec<CertificateDetails>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CertificateDetails {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub serial_number: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub subject_alt_names: ::prost::alloc::vec::Vec<SubjectAlternateName>,
    #[prost(uint64, tag = "4")]
    pub days_until_expiration: u64,
    #[prost(message, optional, tag = "5")]
    pub valid_from: ::core::option::Option<
        super::super::super::google::protobuf::Timestamp,
    >,
    #[prost(message, optional, tag = "6")]
    pub expiration_time: ::core::option::Option<
        super::super::super::google::protobuf::Timestamp,
    >,
    #[prost(message, optional, tag = "7")]
    pub ocsp_details: ::core::option::Option<certificate_details::OcspDetails>,
}
/// Nested message and enum types in `CertificateDetails`.
pub mod certificate_details {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct OcspDetails {
        #[prost(message, optional, tag = "1")]
        pub valid_from: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
        #[prost(message, optional, tag = "2")]
        pub expiration: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubjectAlternateName {
    #[prost(oneof = "subject_alternate_name::Name", tags = "1, 2, 3")]
    pub name: ::core::option::Option<subject_alternate_name::Name>,
}
/// Nested message and enum types in `SubjectAlternateName`.
pub mod subject_alternate_name {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Name {
        #[prost(string, tag = "1")]
        Dns(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        Uri(::prost::alloc::string::String),
        #[prost(string, tag = "3")]
        IpAddress(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimpleMetric {
    #[prost(enumeration = "simple_metric::Type", tag = "1")]
    pub r#type: i32,
    #[prost(uint64, tag = "2")]
    pub value: u64,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SimpleMetric`.
pub mod simple_metric {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Counter = 0,
        Gauge = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Counter => "COUNTER",
                Type::Gauge => "GAUGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COUNTER" => Some(Self::Counter),
                "GAUGE" => Some(Self::Gauge),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Clusters {
    #[prost(message, repeated, tag = "1")]
    pub cluster_statuses: ::prost::alloc::vec::Vec<ClusterStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterStatus {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub added_via_api: bool,
    #[prost(message, optional, tag = "3")]
    pub success_rate_ejection_threshold: ::core::option::Option<
        super::super::r#type::v3::Percent,
    >,
    #[prost(message, repeated, tag = "4")]
    pub host_statuses: ::prost::alloc::vec::Vec<HostStatus>,
    #[prost(message, optional, tag = "5")]
    pub local_origin_success_rate_ejection_threshold: ::core::option::Option<
        super::super::r#type::v3::Percent,
    >,
    #[prost(message, optional, tag = "6")]
    pub circuit_breakers: ::core::option::Option<
        super::super::config::cluster::v3::CircuitBreakers,
    >,
    #[prost(string, tag = "7")]
    pub observability_name: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub eds_service_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HostStatus {
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<super::super::config::core::v3::Address>,
    #[prost(message, repeated, tag = "2")]
    pub stats: ::prost::alloc::vec::Vec<SimpleMetric>,
    #[prost(message, optional, tag = "3")]
    pub health_status: ::core::option::Option<HostHealthStatus>,
    #[prost(message, optional, tag = "4")]
    pub success_rate: ::core::option::Option<super::super::r#type::v3::Percent>,
    #[prost(uint32, tag = "5")]
    pub weight: u32,
    #[prost(string, tag = "6")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(uint32, tag = "7")]
    pub priority: u32,
    #[prost(message, optional, tag = "8")]
    pub local_origin_success_rate: ::core::option::Option<
        super::super::r#type::v3::Percent,
    >,
    #[prost(message, optional, tag = "9")]
    pub locality: ::core::option::Option<super::super::config::core::v3::Locality>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HostHealthStatus {
    #[prost(bool, tag = "1")]
    pub failed_active_health_check: bool,
    #[prost(bool, tag = "2")]
    pub failed_outlier_check: bool,
    #[prost(bool, tag = "4")]
    pub failed_active_degraded_check: bool,
    #[prost(bool, tag = "5")]
    pub pending_dynamic_removal: bool,
    #[prost(bool, tag = "6")]
    pub pending_active_hc: bool,
    #[prost(bool, tag = "7")]
    pub excluded_via_immediate_hc_fail: bool,
    #[prost(bool, tag = "8")]
    pub active_hc_timeout: bool,
    #[prost(enumeration = "super::super::config::core::v3::HealthStatus", tag = "3")]
    pub eds_health_status: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFailureState {
    #[prost(message, optional, tag = "1")]
    pub failed_configuration: ::core::option::Option<
        super::super::super::google::protobuf::Any,
    >,
    #[prost(message, optional, tag = "2")]
    pub last_update_attempt: ::core::option::Option<
        super::super::super::google::protobuf::Timestamp,
    >,
    #[prost(string, tag = "3")]
    pub details: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub version_info: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListenersConfigDump {
    #[prost(string, tag = "1")]
    pub version_info: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub static_listeners: ::prost::alloc::vec::Vec<
        listeners_config_dump::StaticListener,
    >,
    #[prost(message, repeated, tag = "3")]
    pub dynamic_listeners: ::prost::alloc::vec::Vec<
        listeners_config_dump::DynamicListener,
    >,
}
/// Nested message and enum types in `ListenersConfigDump`.
pub mod listeners_config_dump {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StaticListener {
        #[prost(message, optional, tag = "1")]
        pub listener: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        #[prost(message, optional, tag = "2")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DynamicListenerState {
        #[prost(string, tag = "1")]
        pub version_info: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub listener: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        #[prost(message, optional, tag = "3")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DynamicListener {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub active_state: ::core::option::Option<DynamicListenerState>,
        #[prost(message, optional, tag = "3")]
        pub warming_state: ::core::option::Option<DynamicListenerState>,
        #[prost(message, optional, tag = "4")]
        pub draining_state: ::core::option::Option<DynamicListenerState>,
        #[prost(message, optional, tag = "5")]
        pub error_state: ::core::option::Option<super::UpdateFailureState>,
        #[prost(enumeration = "super::ClientResourceStatus", tag = "6")]
        pub client_status: i32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClustersConfigDump {
    #[prost(string, tag = "1")]
    pub version_info: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub static_clusters: ::prost::alloc::vec::Vec<clusters_config_dump::StaticCluster>,
    #[prost(message, repeated, tag = "3")]
    pub dynamic_active_clusters: ::prost::alloc::vec::Vec<
        clusters_config_dump::DynamicCluster,
    >,
    #[prost(message, repeated, tag = "4")]
    pub dynamic_warming_clusters: ::prost::alloc::vec::Vec<
        clusters_config_dump::DynamicCluster,
    >,
}
/// Nested message and enum types in `ClustersConfigDump`.
pub mod clusters_config_dump {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StaticCluster {
        #[prost(message, optional, tag = "1")]
        pub cluster: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        #[prost(message, optional, tag = "2")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DynamicCluster {
        #[prost(string, tag = "1")]
        pub version_info: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub cluster: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        #[prost(message, optional, tag = "3")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
        #[prost(message, optional, tag = "4")]
        pub error_state: ::core::option::Option<super::UpdateFailureState>,
        #[prost(enumeration = "super::ClientResourceStatus", tag = "5")]
        pub client_status: i32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoutesConfigDump {
    #[prost(message, repeated, tag = "2")]
    pub static_route_configs: ::prost::alloc::vec::Vec<
        routes_config_dump::StaticRouteConfig,
    >,
    #[prost(message, repeated, tag = "3")]
    pub dynamic_route_configs: ::prost::alloc::vec::Vec<
        routes_config_dump::DynamicRouteConfig,
    >,
}
/// Nested message and enum types in `RoutesConfigDump`.
pub mod routes_config_dump {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StaticRouteConfig {
        #[prost(message, optional, tag = "1")]
        pub route_config: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        #[prost(message, optional, tag = "2")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DynamicRouteConfig {
        #[prost(string, tag = "1")]
        pub version_info: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub route_config: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        #[prost(message, optional, tag = "3")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
        #[prost(message, optional, tag = "4")]
        pub error_state: ::core::option::Option<super::UpdateFailureState>,
        #[prost(enumeration = "super::ClientResourceStatus", tag = "5")]
        pub client_status: i32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScopedRoutesConfigDump {
    #[prost(message, repeated, tag = "1")]
    pub inline_scoped_route_configs: ::prost::alloc::vec::Vec<
        scoped_routes_config_dump::InlineScopedRouteConfigs,
    >,
    #[prost(message, repeated, tag = "2")]
    pub dynamic_scoped_route_configs: ::prost::alloc::vec::Vec<
        scoped_routes_config_dump::DynamicScopedRouteConfigs,
    >,
}
/// Nested message and enum types in `ScopedRoutesConfigDump`.
pub mod scoped_routes_config_dump {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InlineScopedRouteConfigs {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub scoped_route_configs: ::prost::alloc::vec::Vec<
            super::super::super::super::google::protobuf::Any,
        >,
        #[prost(message, optional, tag = "3")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DynamicScopedRouteConfigs {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub version_info: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub scoped_route_configs: ::prost::alloc::vec::Vec<
            super::super::super::super::google::protobuf::Any,
        >,
        #[prost(message, optional, tag = "4")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
        #[prost(message, optional, tag = "5")]
        pub error_state: ::core::option::Option<super::UpdateFailureState>,
        #[prost(enumeration = "super::ClientResourceStatus", tag = "6")]
        pub client_status: i32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndpointsConfigDump {
    #[prost(message, repeated, tag = "2")]
    pub static_endpoint_configs: ::prost::alloc::vec::Vec<
        endpoints_config_dump::StaticEndpointConfig,
    >,
    #[prost(message, repeated, tag = "3")]
    pub dynamic_endpoint_configs: ::prost::alloc::vec::Vec<
        endpoints_config_dump::DynamicEndpointConfig,
    >,
}
/// Nested message and enum types in `EndpointsConfigDump`.
pub mod endpoints_config_dump {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StaticEndpointConfig {
        #[prost(message, optional, tag = "1")]
        pub endpoint_config: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        #[prost(message, optional, tag = "2")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DynamicEndpointConfig {
        #[prost(string, tag = "1")]
        pub version_info: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub endpoint_config: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        #[prost(message, optional, tag = "3")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
        #[prost(message, optional, tag = "4")]
        pub error_state: ::core::option::Option<super::UpdateFailureState>,
        #[prost(enumeration = "super::ClientResourceStatus", tag = "5")]
        pub client_status: i32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EcdsConfigDump {
    #[prost(message, repeated, tag = "1")]
    pub ecds_filters: ::prost::alloc::vec::Vec<ecds_config_dump::EcdsFilterConfig>,
}
/// Nested message and enum types in `EcdsConfigDump`.
pub mod ecds_config_dump {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EcdsFilterConfig {
        #[prost(string, tag = "1")]
        pub version_info: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub ecds_filter: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        #[prost(message, optional, tag = "3")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
        #[prost(message, optional, tag = "4")]
        pub error_state: ::core::option::Option<super::UpdateFailureState>,
        #[prost(enumeration = "super::ClientResourceStatus", tag = "5")]
        pub client_status: i32,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClientResourceStatus {
    Unknown = 0,
    Requested = 1,
    DoesNotExist = 2,
    Acked = 3,
    Nacked = 4,
}
impl ClientResourceStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ClientResourceStatus::Unknown => "UNKNOWN",
            ClientResourceStatus::Requested => "REQUESTED",
            ClientResourceStatus::DoesNotExist => "DOES_NOT_EXIST",
            ClientResourceStatus::Acked => "ACKED",
            ClientResourceStatus::Nacked => "NACKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "REQUESTED" => Some(Self::Requested),
            "DOES_NOT_EXIST" => Some(Self::DoesNotExist),
            "ACKED" => Some(Self::Acked),
            "NACKED" => Some(Self::Nacked),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigDump {
    #[prost(message, repeated, tag = "1")]
    pub configs: ::prost::alloc::vec::Vec<super::super::super::google::protobuf::Any>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BootstrapConfigDump {
    #[prost(message, optional, tag = "1")]
    pub bootstrap: ::core::option::Option<
        super::super::config::bootstrap::v3::Bootstrap,
    >,
    #[prost(message, optional, tag = "2")]
    pub last_updated: ::core::option::Option<
        super::super::super::google::protobuf::Timestamp,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecretsConfigDump {
    #[prost(message, repeated, tag = "1")]
    pub static_secrets: ::prost::alloc::vec::Vec<secrets_config_dump::StaticSecret>,
    #[prost(message, repeated, tag = "2")]
    pub dynamic_active_secrets: ::prost::alloc::vec::Vec<
        secrets_config_dump::DynamicSecret,
    >,
    #[prost(message, repeated, tag = "3")]
    pub dynamic_warming_secrets: ::prost::alloc::vec::Vec<
        secrets_config_dump::DynamicSecret,
    >,
}
/// Nested message and enum types in `SecretsConfigDump`.
pub mod secrets_config_dump {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DynamicSecret {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub version_info: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
        #[prost(message, optional, tag = "4")]
        pub secret: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
        #[prost(message, optional, tag = "5")]
        pub error_state: ::core::option::Option<super::UpdateFailureState>,
        #[prost(enumeration = "super::ClientResourceStatus", tag = "6")]
        pub client_status: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StaticSecret {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub last_updated: ::core::option::Option<
            super::super::super::super::google::protobuf::Timestamp,
        >,
        #[prost(message, optional, tag = "3")]
        pub secret: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnreadyTargetsDumps {
    #[prost(message, repeated, tag = "1")]
    pub unready_targets_dumps: ::prost::alloc::vec::Vec<
        unready_targets_dumps::UnreadyTargetsDump,
    >,
}
/// Nested message and enum types in `UnreadyTargetsDumps`.
pub mod unready_targets_dumps {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UnreadyTargetsDump {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub target_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Listeners {
    #[prost(message, repeated, tag = "1")]
    pub listener_statuses: ::prost::alloc::vec::Vec<ListenerStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListenerStatus {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub local_address: ::core::option::Option<super::super::config::core::v3::Address>,
    #[prost(message, repeated, tag = "3")]
    pub additional_local_addresses: ::prost::alloc::vec::Vec<
        super::super::config::core::v3::Address,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Memory {
    #[prost(uint64, tag = "1")]
    pub allocated: u64,
    #[prost(uint64, tag = "2")]
    pub heap_size: u64,
    #[prost(uint64, tag = "3")]
    pub pageheap_unmapped: u64,
    #[prost(uint64, tag = "4")]
    pub pageheap_free: u64,
    #[prost(uint64, tag = "5")]
    pub total_thread_cache: u64,
    #[prost(uint64, tag = "6")]
    pub total_physical_bytes: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MutexStats {
    #[prost(uint64, tag = "1")]
    pub num_contentions: u64,
    #[prost(uint64, tag = "2")]
    pub current_wait_cycles: u64,
    #[prost(uint64, tag = "3")]
    pub lifetime_wait_cycles: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerInfo {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    #[prost(enumeration = "server_info::State", tag = "2")]
    pub state: i32,
    #[prost(message, optional, tag = "3")]
    pub uptime_current_epoch: ::core::option::Option<
        super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "4")]
    pub uptime_all_epochs: ::core::option::Option<
        super::super::super::google::protobuf::Duration,
    >,
    #[prost(string, tag = "5")]
    pub hot_restart_version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub command_line_options: ::core::option::Option<CommandLineOptions>,
    #[prost(message, optional, tag = "7")]
    pub node: ::core::option::Option<super::super::config::core::v3::Node>,
}
/// Nested message and enum types in `ServerInfo`.
pub mod server_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Live = 0,
        Draining = 1,
        PreInitializing = 2,
        Initializing = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Live => "LIVE",
                State::Draining => "DRAINING",
                State::PreInitializing => "PRE_INITIALIZING",
                State::Initializing => "INITIALIZING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LIVE" => Some(Self::Live),
                "DRAINING" => Some(Self::Draining),
                "PRE_INITIALIZING" => Some(Self::PreInitializing),
                "INITIALIZING" => Some(Self::Initializing),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandLineOptions {
    #[prost(uint64, tag = "1")]
    pub base_id: u64,
    #[prost(bool, tag = "31")]
    pub use_dynamic_base_id: bool,
    #[prost(bool, tag = "39")]
    pub skip_hot_restart_on_no_parent: bool,
    #[prost(bool, tag = "40")]
    pub skip_hot_restart_parent_stats: bool,
    #[prost(string, tag = "32")]
    pub base_id_path: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub concurrency: u32,
    #[prost(string, tag = "3")]
    pub config_path: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub config_yaml: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub allow_unknown_static_fields: bool,
    #[prost(bool, tag = "26")]
    pub reject_unknown_dynamic_fields: bool,
    #[prost(bool, tag = "30")]
    pub ignore_unknown_dynamic_fields: bool,
    #[prost(string, tag = "6")]
    pub admin_address_path: ::prost::alloc::string::String,
    #[prost(enumeration = "command_line_options::IpVersion", tag = "7")]
    pub local_address_ip_version: i32,
    #[prost(string, tag = "8")]
    pub log_level: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub component_log_level: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub log_format: ::prost::alloc::string::String,
    #[prost(bool, tag = "27")]
    pub log_format_escaped: bool,
    #[prost(string, tag = "11")]
    pub log_path: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub service_cluster: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub service_node: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub service_zone: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "16")]
    pub file_flush_interval: ::core::option::Option<
        super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "17")]
    pub drain_time: ::core::option::Option<
        super::super::super::google::protobuf::Duration,
    >,
    #[prost(enumeration = "command_line_options::DrainStrategy", tag = "33")]
    pub drain_strategy: i32,
    #[prost(message, optional, tag = "18")]
    pub parent_shutdown_time: ::core::option::Option<
        super::super::super::google::protobuf::Duration,
    >,
    #[prost(enumeration = "command_line_options::Mode", tag = "19")]
    pub mode: i32,
    #[prost(bool, tag = "22")]
    pub disable_hot_restart: bool,
    #[prost(bool, tag = "23")]
    pub enable_mutex_tracing: bool,
    #[prost(uint32, tag = "24")]
    pub restart_epoch: u32,
    #[prost(bool, tag = "25")]
    pub cpuset_threads: bool,
    #[prost(string, repeated, tag = "28")]
    pub disabled_extensions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "34")]
    pub enable_fine_grain_logging: bool,
    #[prost(string, tag = "35")]
    pub socket_path: ::prost::alloc::string::String,
    #[prost(uint32, tag = "36")]
    pub socket_mode: u32,
    #[prost(bool, tag = "37")]
    pub enable_core_dump: bool,
    #[prost(string, repeated, tag = "38")]
    pub stats_tag: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `CommandLineOptions`.
pub mod command_line_options {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IpVersion {
        V4 = 0,
        V6 = 1,
    }
    impl IpVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IpVersion::V4 => "v4",
                IpVersion::V6 => "v6",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "v4" => Some(Self::V4),
                "v6" => Some(Self::V6),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        Serve = 0,
        Validate = 1,
        InitOnly = 2,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Mode::Serve => "Serve",
                Mode::Validate => "Validate",
                Mode::InitOnly => "InitOnly",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Serve" => Some(Self::Serve),
                "Validate" => Some(Self::Validate),
                "InitOnly" => Some(Self::InitOnly),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DrainStrategy {
        Gradual = 0,
        Immediate = 1,
    }
    impl DrainStrategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DrainStrategy::Gradual => "Gradual",
                DrainStrategy::Immediate => "Immediate",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Gradual" => Some(Self::Gradual),
                "Immediate" => Some(Self::Immediate),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TapRequest {
    #[prost(string, tag = "1")]
    pub config_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tap_config: ::core::option::Option<super::super::config::tap::v3::TapConfig>,
}
