// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VirtualHost {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub routes: ::prost::alloc::vec::Vec<Route>,
    #[prost(message, optional, tag = "21")]
    pub matcher: ::core::option::Option<
        super::super::super::super::xds::r#type::matcher::v3::Matcher,
    >,
    #[prost(enumeration = "virtual_host::TlsRequirementType", tag = "4")]
    pub require_tls: i32,
    #[prost(message, repeated, tag = "5")]
    pub virtual_clusters: ::prost::alloc::vec::Vec<VirtualCluster>,
    #[prost(message, repeated, tag = "6")]
    pub rate_limits: ::prost::alloc::vec::Vec<RateLimit>,
    #[prost(message, repeated, tag = "7")]
    pub request_headers_to_add: ::prost::alloc::vec::Vec<
        super::super::core::v3::HeaderValueOption,
    >,
    #[prost(string, repeated, tag = "13")]
    pub request_headers_to_remove: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "10")]
    pub response_headers_to_add: ::prost::alloc::vec::Vec<
        super::super::core::v3::HeaderValueOption,
    >,
    #[prost(string, repeated, tag = "11")]
    pub response_headers_to_remove: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[deprecated]
    #[prost(message, optional, tag = "8")]
    pub cors: ::core::option::Option<CorsPolicy>,
    #[prost(map = "string, message", tag = "15")]
    pub typed_per_filter_config: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::super::super::google::protobuf::Any,
    >,
    #[prost(bool, tag = "14")]
    pub include_request_attempt_count: bool,
    #[prost(bool, tag = "19")]
    pub include_attempt_count_in_response: bool,
    #[prost(message, optional, tag = "16")]
    pub retry_policy: ::core::option::Option<RetryPolicy>,
    #[prost(message, optional, tag = "20")]
    pub retry_policy_typed_config: ::core::option::Option<
        super::super::super::super::google::protobuf::Any,
    >,
    #[prost(message, optional, tag = "17")]
    pub hedge_policy: ::core::option::Option<HedgePolicy>,
    #[prost(bool, tag = "23")]
    pub include_is_timeout_retry_header: bool,
    #[prost(message, optional, tag = "18")]
    pub per_request_buffer_limit_bytes: ::core::option::Option<
        super::super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(message, repeated, tag = "22")]
    pub request_mirror_policies: ::prost::alloc::vec::Vec<
        route_action::RequestMirrorPolicy,
    >,
    #[prost(message, optional, tag = "24")]
    pub metadata: ::core::option::Option<super::super::core::v3::Metadata>,
}
/// Nested message and enum types in `VirtualHost`.
pub mod virtual_host {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TlsRequirementType {
        None = 0,
        ExternalOnly = 1,
        All = 2,
    }
    impl TlsRequirementType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TlsRequirementType::None => "NONE",
                TlsRequirementType::ExternalOnly => "EXTERNAL_ONLY",
                TlsRequirementType::All => "ALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "EXTERNAL_ONLY" => Some(Self::ExternalOnly),
                "ALL" => Some(Self::All),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterAction {
    #[prost(message, optional, tag = "1")]
    pub action: ::core::option::Option<
        super::super::super::super::google::protobuf::Any,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteList {
    #[prost(message, repeated, tag = "1")]
    pub routes: ::prost::alloc::vec::Vec<Route>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Route {
    #[prost(string, tag = "14")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1")]
    pub r#match: ::core::option::Option<RouteMatch>,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<super::super::core::v3::Metadata>,
    #[prost(message, optional, tag = "5")]
    pub decorator: ::core::option::Option<Decorator>,
    #[prost(map = "string, message", tag = "13")]
    pub typed_per_filter_config: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::super::super::google::protobuf::Any,
    >,
    #[prost(message, repeated, tag = "9")]
    pub request_headers_to_add: ::prost::alloc::vec::Vec<
        super::super::core::v3::HeaderValueOption,
    >,
    #[prost(string, repeated, tag = "12")]
    pub request_headers_to_remove: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "10")]
    pub response_headers_to_add: ::prost::alloc::vec::Vec<
        super::super::core::v3::HeaderValueOption,
    >,
    #[prost(string, repeated, tag = "11")]
    pub response_headers_to_remove: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "15")]
    pub tracing: ::core::option::Option<Tracing>,
    #[prost(message, optional, tag = "16")]
    pub per_request_buffer_limit_bytes: ::core::option::Option<
        super::super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(string, tag = "19")]
    pub stat_prefix: ::prost::alloc::string::String,
    #[prost(oneof = "route::Action", tags = "2, 3, 7, 17, 18")]
    pub action: ::core::option::Option<route::Action>,
}
/// Nested message and enum types in `Route`.
pub mod route {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Action {
        #[prost(message, tag = "2")]
        Route(super::RouteAction),
        #[prost(message, tag = "3")]
        Redirect(super::RedirectAction),
        #[prost(message, tag = "7")]
        DirectResponse(super::DirectResponseAction),
        #[prost(message, tag = "17")]
        FilterAction(super::FilterAction),
        #[prost(message, tag = "18")]
        NonForwardingAction(super::NonForwardingAction),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeightedCluster {
    #[prost(message, repeated, tag = "1")]
    pub clusters: ::prost::alloc::vec::Vec<weighted_cluster::ClusterWeight>,
    #[deprecated]
    #[prost(message, optional, tag = "3")]
    pub total_weight: ::core::option::Option<
        super::super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(string, tag = "2")]
    pub runtime_key_prefix: ::prost::alloc::string::String,
    #[prost(oneof = "weighted_cluster::RandomValueSpecifier", tags = "4")]
    pub random_value_specifier: ::core::option::Option<
        weighted_cluster::RandomValueSpecifier,
    >,
}
/// Nested message and enum types in `WeightedCluster`.
pub mod weighted_cluster {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClusterWeight {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "12")]
        pub cluster_header: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub weight: ::core::option::Option<
            super::super::super::super::super::google::protobuf::UInt32Value,
        >,
        #[prost(message, optional, tag = "3")]
        pub metadata_match: ::core::option::Option<
            super::super::super::core::v3::Metadata,
        >,
        #[prost(message, repeated, tag = "4")]
        pub request_headers_to_add: ::prost::alloc::vec::Vec<
            super::super::super::core::v3::HeaderValueOption,
        >,
        #[prost(string, repeated, tag = "9")]
        pub request_headers_to_remove: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        #[prost(message, repeated, tag = "5")]
        pub response_headers_to_add: ::prost::alloc::vec::Vec<
            super::super::super::core::v3::HeaderValueOption,
        >,
        #[prost(string, repeated, tag = "6")]
        pub response_headers_to_remove: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        #[prost(map = "string, message", tag = "10")]
        pub typed_per_filter_config: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::super::super::super::super::google::protobuf::Any,
        >,
        #[prost(oneof = "cluster_weight::HostRewriteSpecifier", tags = "11")]
        pub host_rewrite_specifier: ::core::option::Option<
            cluster_weight::HostRewriteSpecifier,
        >,
    }
    /// Nested message and enum types in `ClusterWeight`.
    pub mod cluster_weight {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum HostRewriteSpecifier {
            #[prost(string, tag = "11")]
            HostRewriteLiteral(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RandomValueSpecifier {
        #[prost(string, tag = "4")]
        HeaderName(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterSpecifierPlugin {
    #[prost(message, optional, tag = "1")]
    pub extension: ::core::option::Option<super::super::core::v3::TypedExtensionConfig>,
    #[prost(bool, tag = "2")]
    pub is_optional: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteMatch {
    #[prost(message, optional, tag = "4")]
    pub case_sensitive: ::core::option::Option<
        super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(message, optional, tag = "9")]
    pub runtime_fraction: ::core::option::Option<
        super::super::core::v3::RuntimeFractionalPercent,
    >,
    #[prost(message, repeated, tag = "6")]
    pub headers: ::prost::alloc::vec::Vec<HeaderMatcher>,
    #[prost(message, repeated, tag = "7")]
    pub query_parameters: ::prost::alloc::vec::Vec<QueryParameterMatcher>,
    #[prost(message, optional, tag = "8")]
    pub grpc: ::core::option::Option<route_match::GrpcRouteMatchOptions>,
    #[prost(message, optional, tag = "11")]
    pub tls_context: ::core::option::Option<route_match::TlsContextMatchOptions>,
    #[prost(message, repeated, tag = "13")]
    pub dynamic_metadata: ::prost::alloc::vec::Vec<
        super::super::super::r#type::matcher::v3::MetadataMatcher,
    >,
    #[prost(oneof = "route_match::PathSpecifier", tags = "1, 2, 10, 12, 14, 15")]
    pub path_specifier: ::core::option::Option<route_match::PathSpecifier>,
}
/// Nested message and enum types in `RouteMatch`.
pub mod route_match {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct GrpcRouteMatchOptions {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TlsContextMatchOptions {
        #[prost(message, optional, tag = "1")]
        pub presented: ::core::option::Option<
            super::super::super::super::super::google::protobuf::BoolValue,
        >,
        #[prost(message, optional, tag = "2")]
        pub validated: ::core::option::Option<
            super::super::super::super::super::google::protobuf::BoolValue,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ConnectMatcher {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PathSpecifier {
        #[prost(string, tag = "1")]
        Prefix(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        Path(::prost::alloc::string::String),
        #[prost(message, tag = "10")]
        SafeRegex(super::super::super::super::r#type::matcher::v3::RegexMatcher),
        #[prost(message, tag = "12")]
        ConnectMatcher(ConnectMatcher),
        #[prost(string, tag = "14")]
        PathSeparatedPrefix(::prost::alloc::string::String),
        #[prost(message, tag = "15")]
        PathMatchPolicy(super::super::super::core::v3::TypedExtensionConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CorsPolicy {
    #[prost(message, repeated, tag = "11")]
    pub allow_origin_string_match: ::prost::alloc::vec::Vec<
        super::super::super::r#type::matcher::v3::StringMatcher,
    >,
    #[prost(string, tag = "2")]
    pub allow_methods: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub allow_headers: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub expose_headers: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub max_age: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub allow_credentials: ::core::option::Option<
        super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(message, optional, tag = "10")]
    pub shadow_enabled: ::core::option::Option<
        super::super::core::v3::RuntimeFractionalPercent,
    >,
    #[prost(message, optional, tag = "12")]
    pub allow_private_network_access: ::core::option::Option<
        super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(message, optional, tag = "13")]
    pub forward_not_matching_preflights: ::core::option::Option<
        super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(oneof = "cors_policy::EnabledSpecifier", tags = "9")]
    pub enabled_specifier: ::core::option::Option<cors_policy::EnabledSpecifier>,
}
/// Nested message and enum types in `CorsPolicy`.
pub mod cors_policy {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EnabledSpecifier {
        #[prost(message, tag = "9")]
        FilterEnabled(super::super::super::core::v3::RuntimeFractionalPercent),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteAction {
    #[prost(enumeration = "route_action::ClusterNotFoundResponseCode", tag = "20")]
    pub cluster_not_found_response_code: i32,
    #[prost(message, optional, tag = "4")]
    pub metadata_match: ::core::option::Option<super::super::core::v3::Metadata>,
    #[prost(string, tag = "5")]
    pub prefix_rewrite: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "32")]
    pub regex_rewrite: ::core::option::Option<
        super::super::super::r#type::matcher::v3::RegexMatchAndSubstitute,
    >,
    #[prost(message, optional, tag = "41")]
    pub path_rewrite_policy: ::core::option::Option<
        super::super::core::v3::TypedExtensionConfig,
    >,
    #[prost(bool, tag = "38")]
    pub append_x_forwarded_host: bool,
    #[prost(message, optional, tag = "8")]
    pub timeout: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "24")]
    pub idle_timeout: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "40")]
    pub early_data_policy: ::core::option::Option<
        super::super::core::v3::TypedExtensionConfig,
    >,
    #[prost(message, optional, tag = "9")]
    pub retry_policy: ::core::option::Option<RetryPolicy>,
    #[prost(message, optional, tag = "33")]
    pub retry_policy_typed_config: ::core::option::Option<
        super::super::super::super::google::protobuf::Any,
    >,
    #[prost(message, repeated, tag = "30")]
    pub request_mirror_policies: ::prost::alloc::vec::Vec<
        route_action::RequestMirrorPolicy,
    >,
    #[prost(enumeration = "super::super::core::v3::RoutingPriority", tag = "11")]
    pub priority: i32,
    #[prost(message, repeated, tag = "13")]
    pub rate_limits: ::prost::alloc::vec::Vec<RateLimit>,
    #[deprecated]
    #[prost(message, optional, tag = "14")]
    pub include_vh_rate_limits: ::core::option::Option<
        super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(message, repeated, tag = "15")]
    pub hash_policy: ::prost::alloc::vec::Vec<route_action::HashPolicy>,
    #[deprecated]
    #[prost(message, optional, tag = "17")]
    pub cors: ::core::option::Option<CorsPolicy>,
    #[deprecated]
    #[prost(message, optional, tag = "23")]
    pub max_grpc_timeout: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
    #[deprecated]
    #[prost(message, optional, tag = "28")]
    pub grpc_timeout_offset: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, repeated, tag = "25")]
    pub upgrade_configs: ::prost::alloc::vec::Vec<route_action::UpgradeConfig>,
    #[prost(message, optional, tag = "34")]
    pub internal_redirect_policy: ::core::option::Option<InternalRedirectPolicy>,
    #[deprecated]
    #[prost(enumeration = "route_action::InternalRedirectAction", tag = "26")]
    pub internal_redirect_action: i32,
    #[deprecated]
    #[prost(message, optional, tag = "31")]
    pub max_internal_redirects: ::core::option::Option<
        super::super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(message, optional, tag = "27")]
    pub hedge_policy: ::core::option::Option<HedgePolicy>,
    #[prost(message, optional, tag = "36")]
    pub max_stream_duration: ::core::option::Option<route_action::MaxStreamDuration>,
    #[prost(oneof = "route_action::ClusterSpecifier", tags = "1, 2, 3, 37, 39")]
    pub cluster_specifier: ::core::option::Option<route_action::ClusterSpecifier>,
    #[prost(oneof = "route_action::HostRewriteSpecifier", tags = "6, 7, 29, 35")]
    pub host_rewrite_specifier: ::core::option::Option<
        route_action::HostRewriteSpecifier,
    >,
}
/// Nested message and enum types in `RouteAction`.
pub mod route_action {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RequestMirrorPolicy {
        #[prost(string, tag = "1")]
        pub cluster: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub cluster_header: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub runtime_fraction: ::core::option::Option<
            super::super::super::core::v3::RuntimeFractionalPercent,
        >,
        #[prost(message, optional, tag = "4")]
        pub trace_sampled: ::core::option::Option<
            super::super::super::super::super::google::protobuf::BoolValue,
        >,
        #[prost(bool, tag = "6")]
        pub disable_shadow_host_suffix_append: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HashPolicy {
        #[prost(bool, tag = "4")]
        pub terminal: bool,
        #[prost(oneof = "hash_policy::PolicySpecifier", tags = "1, 2, 3, 5, 6")]
        pub policy_specifier: ::core::option::Option<hash_policy::PolicySpecifier>,
    }
    /// Nested message and enum types in `HashPolicy`.
    pub mod hash_policy {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Header {
            #[prost(string, tag = "1")]
            pub header_name: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub regex_rewrite: ::core::option::Option<
                super::super::super::super::super::r#type::matcher::v3::RegexMatchAndSubstitute,
            >,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CookieAttribute {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub value: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Cookie {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub ttl: ::core::option::Option<
                super::super::super::super::super::super::google::protobuf::Duration,
            >,
            #[prost(string, tag = "3")]
            pub path: ::prost::alloc::string::String,
            #[prost(message, repeated, tag = "4")]
            pub attributes: ::prost::alloc::vec::Vec<CookieAttribute>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ConnectionProperties {
            #[prost(bool, tag = "1")]
            pub source_ip: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct QueryParameter {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FilterState {
            #[prost(string, tag = "1")]
            pub key: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum PolicySpecifier {
            #[prost(message, tag = "1")]
            Header(Header),
            #[prost(message, tag = "2")]
            Cookie(Cookie),
            #[prost(message, tag = "3")]
            ConnectionProperties(ConnectionProperties),
            #[prost(message, tag = "5")]
            QueryParameter(QueryParameter),
            #[prost(message, tag = "6")]
            FilterState(FilterState),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpgradeConfig {
        #[prost(string, tag = "1")]
        pub upgrade_type: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub enabled: ::core::option::Option<
            super::super::super::super::super::google::protobuf::BoolValue,
        >,
        #[prost(message, optional, tag = "3")]
        pub connect_config: ::core::option::Option<upgrade_config::ConnectConfig>,
    }
    /// Nested message and enum types in `UpgradeConfig`.
    pub mod upgrade_config {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ConnectConfig {
            #[prost(message, optional, tag = "1")]
            pub proxy_protocol_config: ::core::option::Option<
                super::super::super::super::core::v3::ProxyProtocolConfig,
            >,
            #[prost(bool, tag = "2")]
            pub allow_post: bool,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MaxStreamDuration {
        #[prost(message, optional, tag = "1")]
        pub max_stream_duration: ::core::option::Option<
            super::super::super::super::super::google::protobuf::Duration,
        >,
        #[prost(message, optional, tag = "2")]
        pub grpc_timeout_header_max: ::core::option::Option<
            super::super::super::super::super::google::protobuf::Duration,
        >,
        #[prost(message, optional, tag = "3")]
        pub grpc_timeout_header_offset: ::core::option::Option<
            super::super::super::super::super::google::protobuf::Duration,
        >,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClusterNotFoundResponseCode {
        ServiceUnavailable = 0,
        NotFound = 1,
        InternalServerError = 2,
    }
    impl ClusterNotFoundResponseCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ClusterNotFoundResponseCode::ServiceUnavailable => "SERVICE_UNAVAILABLE",
                ClusterNotFoundResponseCode::NotFound => "NOT_FOUND",
                ClusterNotFoundResponseCode::InternalServerError => {
                    "INTERNAL_SERVER_ERROR"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SERVICE_UNAVAILABLE" => Some(Self::ServiceUnavailable),
                "NOT_FOUND" => Some(Self::NotFound),
                "INTERNAL_SERVER_ERROR" => Some(Self::InternalServerError),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InternalRedirectAction {
        PassThroughInternalRedirect = 0,
        HandleInternalRedirect = 1,
    }
    impl InternalRedirectAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InternalRedirectAction::PassThroughInternalRedirect => {
                    "PASS_THROUGH_INTERNAL_REDIRECT"
                }
                InternalRedirectAction::HandleInternalRedirect => {
                    "HANDLE_INTERNAL_REDIRECT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PASS_THROUGH_INTERNAL_REDIRECT" => {
                    Some(Self::PassThroughInternalRedirect)
                }
                "HANDLE_INTERNAL_REDIRECT" => Some(Self::HandleInternalRedirect),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ClusterSpecifier {
        #[prost(string, tag = "1")]
        Cluster(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        ClusterHeader(::prost::alloc::string::String),
        #[prost(message, tag = "3")]
        WeightedClusters(super::WeightedCluster),
        #[prost(string, tag = "37")]
        ClusterSpecifierPlugin(::prost::alloc::string::String),
        #[prost(message, tag = "39")]
        InlineClusterSpecifierPlugin(super::ClusterSpecifierPlugin),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum HostRewriteSpecifier {
        #[prost(string, tag = "6")]
        HostRewriteLiteral(::prost::alloc::string::String),
        #[prost(message, tag = "7")]
        AutoHostRewrite(super::super::super::super::super::google::protobuf::BoolValue),
        #[prost(string, tag = "29")]
        HostRewriteHeader(::prost::alloc::string::String),
        #[prost(message, tag = "35")]
        HostRewritePathRegex(
            super::super::super::super::r#type::matcher::v3::RegexMatchAndSubstitute,
        ),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetryPolicy {
    #[prost(string, tag = "1")]
    pub retry_on: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub num_retries: ::core::option::Option<
        super::super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(message, optional, tag = "3")]
    pub per_try_timeout: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "13")]
    pub per_try_idle_timeout: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "4")]
    pub retry_priority: ::core::option::Option<retry_policy::RetryPriority>,
    #[prost(message, repeated, tag = "5")]
    pub retry_host_predicate: ::prost::alloc::vec::Vec<retry_policy::RetryHostPredicate>,
    #[prost(message, repeated, tag = "12")]
    pub retry_options_predicates: ::prost::alloc::vec::Vec<
        super::super::core::v3::TypedExtensionConfig,
    >,
    #[prost(int64, tag = "6")]
    pub host_selection_retry_max_attempts: i64,
    #[prost(uint32, repeated, tag = "7")]
    pub retriable_status_codes: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "8")]
    pub retry_back_off: ::core::option::Option<retry_policy::RetryBackOff>,
    #[prost(message, optional, tag = "11")]
    pub rate_limited_retry_back_off: ::core::option::Option<
        retry_policy::RateLimitedRetryBackOff,
    >,
    #[prost(message, repeated, tag = "9")]
    pub retriable_headers: ::prost::alloc::vec::Vec<HeaderMatcher>,
    #[prost(message, repeated, tag = "10")]
    pub retriable_request_headers: ::prost::alloc::vec::Vec<HeaderMatcher>,
}
/// Nested message and enum types in `RetryPolicy`.
pub mod retry_policy {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RetryPriority {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(oneof = "retry_priority::ConfigType", tags = "3")]
        pub config_type: ::core::option::Option<retry_priority::ConfigType>,
    }
    /// Nested message and enum types in `RetryPriority`.
    pub mod retry_priority {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ConfigType {
            #[prost(message, tag = "3")]
            TypedConfig(super::super::super::super::super::super::google::protobuf::Any),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RetryHostPredicate {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(oneof = "retry_host_predicate::ConfigType", tags = "3")]
        pub config_type: ::core::option::Option<retry_host_predicate::ConfigType>,
    }
    /// Nested message and enum types in `RetryHostPredicate`.
    pub mod retry_host_predicate {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ConfigType {
            #[prost(message, tag = "3")]
            TypedConfig(super::super::super::super::super::super::google::protobuf::Any),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RetryBackOff {
        #[prost(message, optional, tag = "1")]
        pub base_interval: ::core::option::Option<
            super::super::super::super::super::google::protobuf::Duration,
        >,
        #[prost(message, optional, tag = "2")]
        pub max_interval: ::core::option::Option<
            super::super::super::super::super::google::protobuf::Duration,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResetHeader {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(enumeration = "ResetHeaderFormat", tag = "2")]
        pub format: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RateLimitedRetryBackOff {
        #[prost(message, repeated, tag = "1")]
        pub reset_headers: ::prost::alloc::vec::Vec<ResetHeader>,
        #[prost(message, optional, tag = "2")]
        pub max_interval: ::core::option::Option<
            super::super::super::super::super::google::protobuf::Duration,
        >,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResetHeaderFormat {
        Seconds = 0,
        UnixTimestamp = 1,
    }
    impl ResetHeaderFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ResetHeaderFormat::Seconds => "SECONDS",
                ResetHeaderFormat::UnixTimestamp => "UNIX_TIMESTAMP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SECONDS" => Some(Self::Seconds),
                "UNIX_TIMESTAMP" => Some(Self::UnixTimestamp),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HedgePolicy {
    #[prost(message, optional, tag = "1")]
    pub initial_requests: ::core::option::Option<
        super::super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(message, optional, tag = "2")]
    pub additional_request_chance: ::core::option::Option<
        super::super::super::r#type::v3::FractionalPercent,
    >,
    #[prost(bool, tag = "3")]
    pub hedge_on_per_try_timeout: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedirectAction {
    #[prost(string, tag = "1")]
    pub host_redirect: ::prost::alloc::string::String,
    #[prost(uint32, tag = "8")]
    pub port_redirect: u32,
    #[prost(enumeration = "redirect_action::RedirectResponseCode", tag = "3")]
    pub response_code: i32,
    #[prost(bool, tag = "6")]
    pub strip_query: bool,
    #[prost(oneof = "redirect_action::SchemeRewriteSpecifier", tags = "4, 7")]
    pub scheme_rewrite_specifier: ::core::option::Option<
        redirect_action::SchemeRewriteSpecifier,
    >,
    #[prost(oneof = "redirect_action::PathRewriteSpecifier", tags = "2, 5, 9")]
    pub path_rewrite_specifier: ::core::option::Option<
        redirect_action::PathRewriteSpecifier,
    >,
}
/// Nested message and enum types in `RedirectAction`.
pub mod redirect_action {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RedirectResponseCode {
        MovedPermanently = 0,
        Found = 1,
        SeeOther = 2,
        TemporaryRedirect = 3,
        PermanentRedirect = 4,
    }
    impl RedirectResponseCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RedirectResponseCode::MovedPermanently => "MOVED_PERMANENTLY",
                RedirectResponseCode::Found => "FOUND",
                RedirectResponseCode::SeeOther => "SEE_OTHER",
                RedirectResponseCode::TemporaryRedirect => "TEMPORARY_REDIRECT",
                RedirectResponseCode::PermanentRedirect => "PERMANENT_REDIRECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MOVED_PERMANENTLY" => Some(Self::MovedPermanently),
                "FOUND" => Some(Self::Found),
                "SEE_OTHER" => Some(Self::SeeOther),
                "TEMPORARY_REDIRECT" => Some(Self::TemporaryRedirect),
                "PERMANENT_REDIRECT" => Some(Self::PermanentRedirect),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SchemeRewriteSpecifier {
        #[prost(bool, tag = "4")]
        HttpsRedirect(bool),
        #[prost(string, tag = "7")]
        SchemeRedirect(::prost::alloc::string::String),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PathRewriteSpecifier {
        #[prost(string, tag = "2")]
        PathRedirect(::prost::alloc::string::String),
        #[prost(string, tag = "5")]
        PrefixRewrite(::prost::alloc::string::String),
        #[prost(message, tag = "9")]
        RegexRewrite(
            super::super::super::super::r#type::matcher::v3::RegexMatchAndSubstitute,
        ),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectResponseAction {
    #[prost(uint32, tag = "1")]
    pub status: u32,
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<super::super::core::v3::DataSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NonForwardingAction {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Decorator {
    #[prost(string, tag = "1")]
    pub operation: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub propagate: ::core::option::Option<
        super::super::super::super::google::protobuf::BoolValue,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tracing {
    #[prost(message, optional, tag = "1")]
    pub client_sampling: ::core::option::Option<
        super::super::super::r#type::v3::FractionalPercent,
    >,
    #[prost(message, optional, tag = "2")]
    pub random_sampling: ::core::option::Option<
        super::super::super::r#type::v3::FractionalPercent,
    >,
    #[prost(message, optional, tag = "3")]
    pub overall_sampling: ::core::option::Option<
        super::super::super::r#type::v3::FractionalPercent,
    >,
    #[prost(message, repeated, tag = "4")]
    pub custom_tags: ::prost::alloc::vec::Vec<
        super::super::super::r#type::tracing::v3::CustomTag,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VirtualCluster {
    #[prost(message, repeated, tag = "4")]
    pub headers: ::prost::alloc::vec::Vec<HeaderMatcher>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RateLimit {
    #[prost(message, optional, tag = "1")]
    pub stage: ::core::option::Option<
        super::super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(string, tag = "2")]
    pub disable_key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub actions: ::prost::alloc::vec::Vec<rate_limit::Action>,
    #[prost(message, optional, tag = "4")]
    pub limit: ::core::option::Option<rate_limit::Override>,
}
/// Nested message and enum types in `RateLimit`.
pub mod rate_limit {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Action {
        #[prost(
            oneof = "action::ActionSpecifier",
            tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11"
        )]
        pub action_specifier: ::core::option::Option<action::ActionSpecifier>,
    }
    /// Nested message and enum types in `Action`.
    pub mod action {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct SourceCluster {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct DestinationCluster {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RequestHeaders {
            #[prost(string, tag = "1")]
            pub header_name: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub descriptor_key: ::prost::alloc::string::String,
            #[prost(bool, tag = "3")]
            pub skip_if_absent: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct RemoteAddress {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct MaskedRemoteAddress {
            #[prost(message, optional, tag = "1")]
            pub v4_prefix_mask_len: ::core::option::Option<
                super::super::super::super::super::super::google::protobuf::UInt32Value,
            >,
            #[prost(message, optional, tag = "2")]
            pub v6_prefix_mask_len: ::core::option::Option<
                super::super::super::super::super::super::google::protobuf::UInt32Value,
            >,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct GenericKey {
            #[prost(string, tag = "1")]
            pub descriptor_value: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub descriptor_key: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct HeaderValueMatch {
            #[prost(string, tag = "4")]
            pub descriptor_key: ::prost::alloc::string::String,
            #[prost(string, tag = "1")]
            pub descriptor_value: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub expect_match: ::core::option::Option<
                super::super::super::super::super::super::google::protobuf::BoolValue,
            >,
            #[prost(message, repeated, tag = "3")]
            pub headers: ::prost::alloc::vec::Vec<super::super::HeaderMatcher>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DynamicMetaData {
            #[prost(string, tag = "1")]
            pub descriptor_key: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub metadata_key: ::core::option::Option<
                super::super::super::super::super::r#type::metadata::v3::MetadataKey,
            >,
            #[prost(string, tag = "3")]
            pub default_value: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MetaData {
            #[prost(string, tag = "1")]
            pub descriptor_key: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub metadata_key: ::core::option::Option<
                super::super::super::super::super::r#type::metadata::v3::MetadataKey,
            >,
            #[prost(string, tag = "3")]
            pub default_value: ::prost::alloc::string::String,
            #[prost(enumeration = "meta_data::Source", tag = "4")]
            pub source: i32,
            #[prost(bool, tag = "5")]
            pub skip_if_absent: bool,
        }
        /// Nested message and enum types in `MetaData`.
        pub mod meta_data {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Source {
                Dynamic = 0,
                RouteEntry = 1,
            }
            impl Source {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Source::Dynamic => "DYNAMIC",
                        Source::RouteEntry => "ROUTE_ENTRY",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "DYNAMIC" => Some(Self::Dynamic),
                        "ROUTE_ENTRY" => Some(Self::RouteEntry),
                        _ => None,
                    }
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct QueryParameterValueMatch {
            #[prost(string, tag = "4")]
            pub descriptor_key: ::prost::alloc::string::String,
            #[prost(string, tag = "1")]
            pub descriptor_value: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub expect_match: ::core::option::Option<
                super::super::super::super::super::super::google::protobuf::BoolValue,
            >,
            #[prost(message, repeated, tag = "3")]
            pub query_parameters: ::prost::alloc::vec::Vec<
                super::super::QueryParameterMatcher,
            >,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ActionSpecifier {
            #[prost(message, tag = "1")]
            SourceCluster(SourceCluster),
            #[prost(message, tag = "2")]
            DestinationCluster(DestinationCluster),
            #[prost(message, tag = "3")]
            RequestHeaders(RequestHeaders),
            #[prost(message, tag = "4")]
            RemoteAddress(RemoteAddress),
            #[prost(message, tag = "5")]
            GenericKey(GenericKey),
            #[prost(message, tag = "6")]
            HeaderValueMatch(HeaderValueMatch),
            #[prost(message, tag = "7")]
            DynamicMetadata(DynamicMetaData),
            #[prost(message, tag = "8")]
            Metadata(MetaData),
            #[prost(message, tag = "9")]
            Extension(super::super::super::super::core::v3::TypedExtensionConfig),
            #[prost(message, tag = "10")]
            MaskedRemoteAddress(MaskedRemoteAddress),
            #[prost(message, tag = "11")]
            QueryParameterValueMatch(QueryParameterValueMatch),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Override {
        #[prost(oneof = "r#override::OverrideSpecifier", tags = "1")]
        pub override_specifier: ::core::option::Option<r#override::OverrideSpecifier>,
    }
    /// Nested message and enum types in `Override`.
    pub mod r#override {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DynamicMetadata {
            #[prost(message, optional, tag = "1")]
            pub metadata_key: ::core::option::Option<
                super::super::super::super::super::r#type::metadata::v3::MetadataKey,
            >,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum OverrideSpecifier {
            #[prost(message, tag = "1")]
            DynamicMetadata(DynamicMetadata),
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeaderMatcher {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub invert_match: bool,
    #[prost(bool, tag = "14")]
    pub treat_missing_header_as_empty: bool,
    #[prost(
        oneof = "header_matcher::HeaderMatchSpecifier",
        tags = "4, 11, 6, 7, 9, 10, 12, 13"
    )]
    pub header_match_specifier: ::core::option::Option<
        header_matcher::HeaderMatchSpecifier,
    >,
}
/// Nested message and enum types in `HeaderMatcher`.
pub mod header_matcher {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum HeaderMatchSpecifier {
        #[prost(string, tag = "4")]
        ExactMatch(::prost::alloc::string::String),
        #[prost(message, tag = "11")]
        SafeRegexMatch(super::super::super::super::r#type::matcher::v3::RegexMatcher),
        #[prost(message, tag = "6")]
        RangeMatch(super::super::super::super::r#type::v3::Int64Range),
        #[prost(bool, tag = "7")]
        PresentMatch(bool),
        #[prost(string, tag = "9")]
        PrefixMatch(::prost::alloc::string::String),
        #[prost(string, tag = "10")]
        SuffixMatch(::prost::alloc::string::String),
        #[prost(string, tag = "12")]
        ContainsMatch(::prost::alloc::string::String),
        #[prost(message, tag = "13")]
        StringMatch(super::super::super::super::r#type::matcher::v3::StringMatcher),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryParameterMatcher {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(
        oneof = "query_parameter_matcher::QueryParameterMatchSpecifier",
        tags = "5, 6"
    )]
    pub query_parameter_match_specifier: ::core::option::Option<
        query_parameter_matcher::QueryParameterMatchSpecifier,
    >,
}
/// Nested message and enum types in `QueryParameterMatcher`.
pub mod query_parameter_matcher {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum QueryParameterMatchSpecifier {
        #[prost(message, tag = "5")]
        StringMatch(super::super::super::super::r#type::matcher::v3::StringMatcher),
        #[prost(bool, tag = "6")]
        PresentMatch(bool),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InternalRedirectPolicy {
    #[prost(message, optional, tag = "1")]
    pub max_internal_redirects: ::core::option::Option<
        super::super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub redirect_response_codes: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub predicates: ::prost::alloc::vec::Vec<
        super::super::core::v3::TypedExtensionConfig,
    >,
    #[prost(bool, tag = "4")]
    pub allow_cross_scheme_redirect: bool,
    #[prost(string, repeated, tag = "5")]
    pub response_headers_to_copy: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterConfig {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<
        super::super::super::super::google::protobuf::Any,
    >,
    #[prost(bool, tag = "2")]
    pub is_optional: bool,
    #[prost(bool, tag = "3")]
    pub disabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteConfiguration {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub virtual_hosts: ::prost::alloc::vec::Vec<VirtualHost>,
    #[prost(message, optional, tag = "9")]
    pub vhds: ::core::option::Option<Vhds>,
    #[prost(string, repeated, tag = "3")]
    pub internal_only_headers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub response_headers_to_add: ::prost::alloc::vec::Vec<
        super::super::core::v3::HeaderValueOption,
    >,
    #[prost(string, repeated, tag = "5")]
    pub response_headers_to_remove: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "6")]
    pub request_headers_to_add: ::prost::alloc::vec::Vec<
        super::super::core::v3::HeaderValueOption,
    >,
    #[prost(string, repeated, tag = "8")]
    pub request_headers_to_remove: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "10")]
    pub most_specific_header_mutations_wins: bool,
    #[prost(message, optional, tag = "7")]
    pub validate_clusters: ::core::option::Option<
        super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(message, optional, tag = "11")]
    pub max_direct_response_body_size_bytes: ::core::option::Option<
        super::super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(message, repeated, tag = "12")]
    pub cluster_specifier_plugins: ::prost::alloc::vec::Vec<ClusterSpecifierPlugin>,
    #[prost(message, repeated, tag = "13")]
    pub request_mirror_policies: ::prost::alloc::vec::Vec<
        route_action::RequestMirrorPolicy,
    >,
    #[prost(bool, tag = "14")]
    pub ignore_port_in_host_matching: bool,
    #[prost(bool, tag = "15")]
    pub ignore_path_parameters_in_path_matching: bool,
    #[prost(map = "string, message", tag = "16")]
    pub typed_per_filter_config: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::super::super::google::protobuf::Any,
    >,
    #[prost(message, optional, tag = "17")]
    pub metadata: ::core::option::Option<super::super::core::v3::Metadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vhds {
    #[prost(message, optional, tag = "1")]
    pub config_source: ::core::option::Option<super::super::core::v3::ConfigSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScopedRouteConfiguration {
    #[prost(bool, tag = "4")]
    pub on_demand: bool,
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub route_configuration_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub route_configuration: ::core::option::Option<RouteConfiguration>,
    #[prost(message, optional, tag = "3")]
    pub key: ::core::option::Option<scoped_route_configuration::Key>,
}
/// Nested message and enum types in `ScopedRouteConfiguration`.
pub mod scoped_route_configuration {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Key {
        #[prost(message, repeated, tag = "1")]
        pub fragments: ::prost::alloc::vec::Vec<key::Fragment>,
    }
    /// Nested message and enum types in `Key`.
    pub mod key {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Fragment {
            #[prost(oneof = "fragment::Type", tags = "1")]
            pub r#type: ::core::option::Option<fragment::Type>,
        }
        /// Nested message and enum types in `Fragment`.
        pub mod fragment {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Type {
                #[prost(string, tag = "1")]
                StringKey(::prost::alloc::string::String),
            }
        }
    }
}
