// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TraceConfig {
    #[prost(int64, tag = "4")]
    pub max_number_of_attributes: i64,
    #[prost(int64, tag = "5")]
    pub max_number_of_annotations: i64,
    #[prost(int64, tag = "6")]
    pub max_number_of_message_events: i64,
    #[prost(int64, tag = "7")]
    pub max_number_of_links: i64,
    #[prost(oneof = "trace_config::Sampler", tags = "1, 2, 3")]
    pub sampler: ::core::option::Option<trace_config::Sampler>,
}
/// Nested message and enum types in `TraceConfig`.
pub mod trace_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Sampler {
        #[prost(message, tag = "1")]
        ProbabilitySampler(super::ProbabilitySampler),
        #[prost(message, tag = "2")]
        ConstantSampler(super::ConstantSampler),
        #[prost(message, tag = "3")]
        RateLimitingSampler(super::RateLimitingSampler),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProbabilitySampler {
    #[prost(double, tag = "1")]
    pub sampling_probability: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConstantSampler {
    #[prost(enumeration = "constant_sampler::ConstantDecision", tag = "1")]
    pub decision: i32,
}
/// Nested message and enum types in `ConstantSampler`.
pub mod constant_sampler {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConstantDecision {
        AlwaysOff = 0,
        AlwaysOn = 1,
        AlwaysParent = 2,
    }
    impl ConstantDecision {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConstantDecision::AlwaysOff => "ALWAYS_OFF",
                ConstantDecision::AlwaysOn => "ALWAYS_ON",
                ConstantDecision::AlwaysParent => "ALWAYS_PARENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALWAYS_OFF" => Some(Self::AlwaysOff),
                "ALWAYS_ON" => Some(Self::AlwaysOn),
                "ALWAYS_PARENT" => Some(Self::AlwaysParent),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RateLimitingSampler {
    #[prost(int64, tag = "1")]
    pub qps: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Span {
    #[prost(bytes = "vec", tag = "1")]
    pub trace_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub span_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "15")]
    pub tracestate: ::core::option::Option<span::Tracestate>,
    #[prost(bytes = "vec", tag = "3")]
    pub parent_span_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub name: ::core::option::Option<TruncatableString>,
    #[prost(enumeration = "span::SpanKind", tag = "14")]
    pub kind: i32,
    #[prost(message, optional, tag = "5")]
    pub start_time: ::core::option::Option<
        super::super::super::super::google::protobuf::Timestamp,
    >,
    #[prost(message, optional, tag = "6")]
    pub end_time: ::core::option::Option<
        super::super::super::super::google::protobuf::Timestamp,
    >,
    #[prost(message, optional, tag = "7")]
    pub attributes: ::core::option::Option<span::Attributes>,
    #[prost(message, optional, tag = "8")]
    pub stack_trace: ::core::option::Option<StackTrace>,
    #[prost(message, optional, tag = "9")]
    pub time_events: ::core::option::Option<span::TimeEvents>,
    #[prost(message, optional, tag = "10")]
    pub links: ::core::option::Option<span::Links>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<Status>,
    #[prost(message, optional, tag = "16")]
    pub resource: ::core::option::Option<super::super::resource::v1::Resource>,
    #[prost(message, optional, tag = "12")]
    pub same_process_as_parent_span: ::core::option::Option<
        super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(message, optional, tag = "13")]
    pub child_span_count: ::core::option::Option<
        super::super::super::super::google::protobuf::UInt32Value,
    >,
}
/// Nested message and enum types in `Span`.
pub mod span {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Tracestate {
        #[prost(message, repeated, tag = "1")]
        pub entries: ::prost::alloc::vec::Vec<tracestate::Entry>,
    }
    /// Nested message and enum types in `Tracestate`.
    pub mod tracestate {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Entry {
            #[prost(string, tag = "1")]
            pub key: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub value: ::prost::alloc::string::String,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Attributes {
        #[prost(map = "string, message", tag = "1")]
        pub attribute_map: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::AttributeValue,
        >,
        #[prost(int32, tag = "2")]
        pub dropped_attributes_count: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TimeEvent {
        #[prost(message, optional, tag = "1")]
        pub time: ::core::option::Option<
            super::super::super::super::super::google::protobuf::Timestamp,
        >,
        #[prost(oneof = "time_event::Value", tags = "2, 3")]
        pub value: ::core::option::Option<time_event::Value>,
    }
    /// Nested message and enum types in `TimeEvent`.
    pub mod time_event {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Annotation {
            #[prost(message, optional, tag = "1")]
            pub description: ::core::option::Option<super::super::TruncatableString>,
            #[prost(message, optional, tag = "2")]
            pub attributes: ::core::option::Option<super::Attributes>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct MessageEvent {
            #[prost(enumeration = "message_event::Type", tag = "1")]
            pub r#type: i32,
            #[prost(uint64, tag = "2")]
            pub id: u64,
            #[prost(uint64, tag = "3")]
            pub uncompressed_size: u64,
            #[prost(uint64, tag = "4")]
            pub compressed_size: u64,
        }
        /// Nested message and enum types in `MessageEvent`.
        pub mod message_event {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Type {
                Unspecified = 0,
                Sent = 1,
                Received = 2,
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Type::Unspecified => "TYPE_UNSPECIFIED",
                        Type::Sent => "SENT",
                        Type::Received => "RECEIVED",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "SENT" => Some(Self::Sent),
                        "RECEIVED" => Some(Self::Received),
                        _ => None,
                    }
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(message, tag = "2")]
            Annotation(Annotation),
            #[prost(message, tag = "3")]
            MessageEvent(MessageEvent),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TimeEvents {
        #[prost(message, repeated, tag = "1")]
        pub time_event: ::prost::alloc::vec::Vec<TimeEvent>,
        #[prost(int32, tag = "2")]
        pub dropped_annotations_count: i32,
        #[prost(int32, tag = "3")]
        pub dropped_message_events_count: i32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Link {
        #[prost(bytes = "vec", tag = "1")]
        pub trace_id: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", tag = "2")]
        pub span_id: ::prost::alloc::vec::Vec<u8>,
        #[prost(enumeration = "link::Type", tag = "3")]
        pub r#type: i32,
        #[prost(message, optional, tag = "4")]
        pub attributes: ::core::option::Option<Attributes>,
        #[prost(message, optional, tag = "5")]
        pub tracestate: ::core::option::Option<Tracestate>,
    }
    /// Nested message and enum types in `Link`.
    pub mod link {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            Unspecified = 0,
            ChildLinkedSpan = 1,
            ParentLinkedSpan = 2,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Type::Unspecified => "TYPE_UNSPECIFIED",
                    Type::ChildLinkedSpan => "CHILD_LINKED_SPAN",
                    Type::ParentLinkedSpan => "PARENT_LINKED_SPAN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "CHILD_LINKED_SPAN" => Some(Self::ChildLinkedSpan),
                    "PARENT_LINKED_SPAN" => Some(Self::ParentLinkedSpan),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Links {
        #[prost(message, repeated, tag = "1")]
        pub link: ::prost::alloc::vec::Vec<Link>,
        #[prost(int32, tag = "2")]
        pub dropped_links_count: i32,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SpanKind {
        Unspecified = 0,
        Server = 1,
        Client = 2,
    }
    impl SpanKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SpanKind::Unspecified => "SPAN_KIND_UNSPECIFIED",
                SpanKind::Server => "SERVER",
                SpanKind::Client => "CLIENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SPAN_KIND_UNSPECIFIED" => Some(Self::Unspecified),
                "SERVER" => Some(Self::Server),
                "CLIENT" => Some(Self::Client),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Status {
    #[prost(int32, tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributeValue {
    #[prost(oneof = "attribute_value::Value", tags = "1, 2, 3, 4")]
    pub value: ::core::option::Option<attribute_value::Value>,
}
/// Nested message and enum types in `AttributeValue`.
pub mod attribute_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag = "1")]
        StringValue(super::TruncatableString),
        #[prost(int64, tag = "2")]
        IntValue(i64),
        #[prost(bool, tag = "3")]
        BoolValue(bool),
        #[prost(double, tag = "4")]
        DoubleValue(f64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackTrace {
    #[prost(message, optional, tag = "1")]
    pub stack_frames: ::core::option::Option<stack_trace::StackFrames>,
    #[prost(uint64, tag = "2")]
    pub stack_trace_hash_id: u64,
}
/// Nested message and enum types in `StackTrace`.
pub mod stack_trace {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StackFrame {
        #[prost(message, optional, tag = "1")]
        pub function_name: ::core::option::Option<super::TruncatableString>,
        #[prost(message, optional, tag = "2")]
        pub original_function_name: ::core::option::Option<super::TruncatableString>,
        #[prost(message, optional, tag = "3")]
        pub file_name: ::core::option::Option<super::TruncatableString>,
        #[prost(int64, tag = "4")]
        pub line_number: i64,
        #[prost(int64, tag = "5")]
        pub column_number: i64,
        #[prost(message, optional, tag = "6")]
        pub load_module: ::core::option::Option<super::Module>,
        #[prost(message, optional, tag = "7")]
        pub source_version: ::core::option::Option<super::TruncatableString>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StackFrames {
        #[prost(message, repeated, tag = "1")]
        pub frame: ::prost::alloc::vec::Vec<StackFrame>,
        #[prost(int32, tag = "2")]
        pub dropped_frames_count: i32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Module {
    #[prost(message, optional, tag = "1")]
    pub module: ::core::option::Option<TruncatableString>,
    #[prost(message, optional, tag = "2")]
    pub build_id: ::core::option::Option<TruncatableString>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TruncatableString {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub truncated_byte_count: i32,
}
