// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpConnectionManager {
    #[prost(enumeration = "http_connection_manager::CodecType", tag = "1")]
    pub codec_type: i32,
    #[prost(string, tag = "2")]
    pub stat_prefix: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub http_filters: ::prost::alloc::vec::Vec<HttpFilter>,
    #[prost(message, optional, tag = "6")]
    pub add_user_agent: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(message, optional, tag = "7")]
    pub tracing: ::core::option::Option<http_connection_manager::Tracing>,
    #[prost(message, optional, tag = "35")]
    pub common_http_protocol_options: ::core::option::Option<
        super::super::super::super::super::config::core::v3::HttpProtocolOptions,
    >,
    #[prost(message, optional, tag = "8")]
    pub http_protocol_options: ::core::option::Option<
        super::super::super::super::super::config::core::v3::Http1ProtocolOptions,
    >,
    #[prost(message, optional, tag = "9")]
    pub http2_protocol_options: ::core::option::Option<
        super::super::super::super::super::config::core::v3::Http2ProtocolOptions,
    >,
    #[prost(message, optional, tag = "44")]
    pub http3_protocol_options: ::core::option::Option<
        super::super::super::super::super::config::core::v3::Http3ProtocolOptions,
    >,
    #[prost(string, tag = "10")]
    pub server_name: ::prost::alloc::string::String,
    #[prost(
        enumeration = "http_connection_manager::ServerHeaderTransformation",
        tag = "34"
    )]
    pub server_header_transformation: i32,
    #[prost(message, optional, tag = "48")]
    pub scheme_header_transformation: ::core::option::Option<
        super::super::super::super::super::config::core::v3::SchemeHeaderTransformation,
    >,
    #[prost(message, optional, tag = "29")]
    pub max_request_headers_kb: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(message, optional, tag = "24")]
    pub stream_idle_timeout: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "28")]
    pub request_timeout: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "41")]
    pub request_headers_timeout: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "12")]
    pub drain_timeout: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "26")]
    pub delayed_close_timeout: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, repeated, tag = "13")]
    pub access_log: ::prost::alloc::vec::Vec<
        super::super::super::super::super::config::accesslog::v3::AccessLog,
    >,
    #[deprecated]
    #[prost(message, optional, tag = "54")]
    pub access_log_flush_interval: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
    #[deprecated]
    #[prost(bool, tag = "55")]
    pub flush_access_log_on_new_request: bool,
    #[prost(message, optional, tag = "56")]
    pub access_log_options: ::core::option::Option<
        http_connection_manager::HcmAccessLogOptions,
    >,
    #[prost(message, optional, tag = "14")]
    pub use_remote_address: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(uint32, tag = "19")]
    pub xff_num_trusted_hops: u32,
    #[prost(message, repeated, tag = "46")]
    pub original_ip_detection_extensions: ::prost::alloc::vec::Vec<
        super::super::super::super::super::config::core::v3::TypedExtensionConfig,
    >,
    #[prost(message, repeated, tag = "52")]
    pub early_header_mutation_extensions: ::prost::alloc::vec::Vec<
        super::super::super::super::super::config::core::v3::TypedExtensionConfig,
    >,
    #[prost(message, optional, tag = "25")]
    pub internal_address_config: ::core::option::Option<
        http_connection_manager::InternalAddressConfig,
    >,
    #[prost(bool, tag = "21")]
    pub skip_xff_append: bool,
    #[prost(string, tag = "22")]
    pub via: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "15")]
    pub generate_request_id: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(bool, tag = "32")]
    pub preserve_external_request_id: bool,
    #[prost(bool, tag = "37")]
    pub always_set_request_id_in_response: bool,
    #[prost(
        enumeration = "http_connection_manager::ForwardClientCertDetails",
        tag = "16"
    )]
    pub forward_client_cert_details: i32,
    #[prost(message, optional, tag = "17")]
    pub set_current_client_cert_details: ::core::option::Option<
        http_connection_manager::SetCurrentClientCertDetails,
    >,
    #[prost(bool, tag = "18")]
    pub proxy_100_continue: bool,
    #[prost(bool, tag = "20")]
    pub represent_ipv4_remote_address_as_ipv4_mapped_ipv6: bool,
    #[prost(message, repeated, tag = "23")]
    pub upgrade_configs: ::prost::alloc::vec::Vec<
        http_connection_manager::UpgradeConfig,
    >,
    #[prost(message, optional, tag = "30")]
    pub normalize_path: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(bool, tag = "33")]
    pub merge_slashes: bool,
    #[prost(
        enumeration = "http_connection_manager::PathWithEscapedSlashesAction",
        tag = "45"
    )]
    pub path_with_escaped_slashes_action: i32,
    #[prost(message, optional, tag = "36")]
    pub request_id_extension: ::core::option::Option<RequestIdExtension>,
    #[prost(message, optional, tag = "38")]
    pub local_reply_config: ::core::option::Option<LocalReplyConfig>,
    #[prost(bool, tag = "39")]
    pub strip_matching_host_port: bool,
    #[prost(message, optional, tag = "40")]
    pub stream_error_on_invalid_http_message: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(message, optional, tag = "43")]
    pub path_normalization_options: ::core::option::Option<
        http_connection_manager::PathNormalizationOptions,
    >,
    #[prost(bool, tag = "47")]
    pub strip_trailing_host_dot: bool,
    #[prost(message, optional, tag = "49")]
    pub proxy_status_config: ::core::option::Option<
        http_connection_manager::ProxyStatusConfig,
    >,
    #[prost(message, optional, tag = "50")]
    pub typed_header_validation_config: ::core::option::Option<
        super::super::super::super::super::config::core::v3::TypedExtensionConfig,
    >,
    #[prost(bool, tag = "51")]
    pub append_x_forwarded_port: bool,
    #[prost(bool, tag = "57")]
    pub append_local_overload: bool,
    #[prost(message, optional, tag = "53")]
    pub add_proxy_protocol_connection_state: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(oneof = "http_connection_manager::RouteSpecifier", tags = "3, 4, 31")]
    pub route_specifier: ::core::option::Option<http_connection_manager::RouteSpecifier>,
    #[prost(oneof = "http_connection_manager::StripPortMode", tags = "42")]
    pub strip_port_mode: ::core::option::Option<http_connection_manager::StripPortMode>,
}
/// Nested message and enum types in `HttpConnectionManager`.
pub mod http_connection_manager {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Tracing {
        #[prost(message, optional, tag = "3")]
        pub client_sampling: ::core::option::Option<
            super::super::super::super::super::super::r#type::v3::Percent,
        >,
        #[prost(message, optional, tag = "4")]
        pub random_sampling: ::core::option::Option<
            super::super::super::super::super::super::r#type::v3::Percent,
        >,
        #[prost(message, optional, tag = "5")]
        pub overall_sampling: ::core::option::Option<
            super::super::super::super::super::super::r#type::v3::Percent,
        >,
        #[prost(bool, tag = "6")]
        pub verbose: bool,
        #[prost(message, optional, tag = "7")]
        pub max_path_tag_length: ::core::option::Option<
            super::super::super::super::super::super::super::google::protobuf::UInt32Value,
        >,
        #[prost(message, repeated, tag = "8")]
        pub custom_tags: ::prost::alloc::vec::Vec<
            super::super::super::super::super::super::r#type::tracing::v3::CustomTag,
        >,
        #[prost(message, optional, tag = "9")]
        pub provider: ::core::option::Option<
            super::super::super::super::super::super::config::trace::v3::tracing::Http,
        >,
        #[prost(message, optional, tag = "10")]
        pub spawn_upstream_span: ::core::option::Option<
            super::super::super::super::super::super::super::google::protobuf::BoolValue,
        >,
    }
    /// Nested message and enum types in `Tracing`.
    pub mod tracing {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum OperationName {
            Ingress = 0,
            Egress = 1,
        }
        impl OperationName {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    OperationName::Ingress => "INGRESS",
                    OperationName::Egress => "EGRESS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "INGRESS" => Some(Self::Ingress),
                    "EGRESS" => Some(Self::Egress),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InternalAddressConfig {
        #[prost(bool, tag = "1")]
        pub unix_sockets: bool,
        #[prost(message, repeated, tag = "2")]
        pub cidr_ranges: ::prost::alloc::vec::Vec<
            super::super::super::super::super::super::config::core::v3::CidrRange,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SetCurrentClientCertDetails {
        #[prost(message, optional, tag = "1")]
        pub subject: ::core::option::Option<
            super::super::super::super::super::super::super::google::protobuf::BoolValue,
        >,
        #[prost(bool, tag = "3")]
        pub cert: bool,
        #[prost(bool, tag = "6")]
        pub chain: bool,
        #[prost(bool, tag = "4")]
        pub dns: bool,
        #[prost(bool, tag = "5")]
        pub uri: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpgradeConfig {
        #[prost(string, tag = "1")]
        pub upgrade_type: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub filters: ::prost::alloc::vec::Vec<super::HttpFilter>,
        #[prost(message, optional, tag = "3")]
        pub enabled: ::core::option::Option<
            super::super::super::super::super::super::super::google::protobuf::BoolValue,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PathNormalizationOptions {
        #[prost(message, optional, tag = "1")]
        pub forwarding_transformation: ::core::option::Option<
            super::super::super::super::super::super::r#type::http::v3::PathTransformation,
        >,
        #[prost(message, optional, tag = "2")]
        pub http_filter_transformation: ::core::option::Option<
            super::super::super::super::super::super::r#type::http::v3::PathTransformation,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProxyStatusConfig {
        #[prost(bool, tag = "1")]
        pub remove_details: bool,
        #[prost(bool, tag = "2")]
        pub remove_connection_termination_details: bool,
        #[prost(bool, tag = "3")]
        pub remove_response_flags: bool,
        #[prost(bool, tag = "4")]
        pub set_recommended_response_code: bool,
        #[prost(oneof = "proxy_status_config::ProxyName", tags = "5, 6")]
        pub proxy_name: ::core::option::Option<proxy_status_config::ProxyName>,
    }
    /// Nested message and enum types in `ProxyStatusConfig`.
    pub mod proxy_status_config {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ProxyName {
            #[prost(bool, tag = "5")]
            UseNodeId(bool),
            #[prost(string, tag = "6")]
            LiteralProxyName(::prost::alloc::string::String),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct HcmAccessLogOptions {
        #[prost(message, optional, tag = "1")]
        pub access_log_flush_interval: ::core::option::Option<
            super::super::super::super::super::super::super::google::protobuf::Duration,
        >,
        #[prost(bool, tag = "2")]
        pub flush_access_log_on_new_request: bool,
        #[prost(bool, tag = "3")]
        pub flush_log_on_tunnel_successfully_established: bool,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CodecType {
        Auto = 0,
        Http1 = 1,
        Http2 = 2,
        Http3 = 3,
    }
    impl CodecType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CodecType::Auto => "AUTO",
                CodecType::Http1 => "HTTP1",
                CodecType::Http2 => "HTTP2",
                CodecType::Http3 => "HTTP3",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUTO" => Some(Self::Auto),
                "HTTP1" => Some(Self::Http1),
                "HTTP2" => Some(Self::Http2),
                "HTTP3" => Some(Self::Http3),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ServerHeaderTransformation {
        Overwrite = 0,
        AppendIfAbsent = 1,
        PassThrough = 2,
    }
    impl ServerHeaderTransformation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ServerHeaderTransformation::Overwrite => "OVERWRITE",
                ServerHeaderTransformation::AppendIfAbsent => "APPEND_IF_ABSENT",
                ServerHeaderTransformation::PassThrough => "PASS_THROUGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OVERWRITE" => Some(Self::Overwrite),
                "APPEND_IF_ABSENT" => Some(Self::AppendIfAbsent),
                "PASS_THROUGH" => Some(Self::PassThrough),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ForwardClientCertDetails {
        Sanitize = 0,
        ForwardOnly = 1,
        AppendForward = 2,
        SanitizeSet = 3,
        AlwaysForwardOnly = 4,
    }
    impl ForwardClientCertDetails {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ForwardClientCertDetails::Sanitize => "SANITIZE",
                ForwardClientCertDetails::ForwardOnly => "FORWARD_ONLY",
                ForwardClientCertDetails::AppendForward => "APPEND_FORWARD",
                ForwardClientCertDetails::SanitizeSet => "SANITIZE_SET",
                ForwardClientCertDetails::AlwaysForwardOnly => "ALWAYS_FORWARD_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SANITIZE" => Some(Self::Sanitize),
                "FORWARD_ONLY" => Some(Self::ForwardOnly),
                "APPEND_FORWARD" => Some(Self::AppendForward),
                "SANITIZE_SET" => Some(Self::SanitizeSet),
                "ALWAYS_FORWARD_ONLY" => Some(Self::AlwaysForwardOnly),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PathWithEscapedSlashesAction {
        ImplementationSpecificDefault = 0,
        KeepUnchanged = 1,
        RejectRequest = 2,
        UnescapeAndRedirect = 3,
        UnescapeAndForward = 4,
    }
    impl PathWithEscapedSlashesAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PathWithEscapedSlashesAction::ImplementationSpecificDefault => {
                    "IMPLEMENTATION_SPECIFIC_DEFAULT"
                }
                PathWithEscapedSlashesAction::KeepUnchanged => "KEEP_UNCHANGED",
                PathWithEscapedSlashesAction::RejectRequest => "REJECT_REQUEST",
                PathWithEscapedSlashesAction::UnescapeAndRedirect => {
                    "UNESCAPE_AND_REDIRECT"
                }
                PathWithEscapedSlashesAction::UnescapeAndForward => {
                    "UNESCAPE_AND_FORWARD"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IMPLEMENTATION_SPECIFIC_DEFAULT" => {
                    Some(Self::ImplementationSpecificDefault)
                }
                "KEEP_UNCHANGED" => Some(Self::KeepUnchanged),
                "REJECT_REQUEST" => Some(Self::RejectRequest),
                "UNESCAPE_AND_REDIRECT" => Some(Self::UnescapeAndRedirect),
                "UNESCAPE_AND_FORWARD" => Some(Self::UnescapeAndForward),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RouteSpecifier {
        #[prost(message, tag = "3")]
        Rds(super::Rds),
        #[prost(message, tag = "4")]
        RouteConfig(
            super::super::super::super::super::super::config::route::v3::RouteConfiguration,
        ),
        #[prost(message, tag = "31")]
        ScopedRoutes(super::ScopedRoutes),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum StripPortMode {
        #[prost(bool, tag = "42")]
        StripAnyHostPort(bool),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocalReplyConfig {
    #[prost(message, repeated, tag = "1")]
    pub mappers: ::prost::alloc::vec::Vec<ResponseMapper>,
    #[prost(message, optional, tag = "2")]
    pub body_format: ::core::option::Option<
        super::super::super::super::super::config::core::v3::SubstitutionFormatString,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseMapper {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<
        super::super::super::super::super::config::accesslog::v3::AccessLogFilter,
    >,
    #[prost(message, optional, tag = "2")]
    pub status_code: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<
        super::super::super::super::super::config::core::v3::DataSource,
    >,
    #[prost(message, optional, tag = "4")]
    pub body_format_override: ::core::option::Option<
        super::super::super::super::super::config::core::v3::SubstitutionFormatString,
    >,
    #[prost(message, repeated, tag = "5")]
    pub headers_to_add: ::prost::alloc::vec::Vec<
        super::super::super::super::super::config::core::v3::HeaderValueOption,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rds {
    #[prost(message, optional, tag = "1")]
    pub config_source: ::core::option::Option<
        super::super::super::super::super::config::core::v3::ConfigSource,
    >,
    #[prost(string, tag = "2")]
    pub route_config_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScopedRouteConfigurationsList {
    #[prost(message, repeated, tag = "1")]
    pub scoped_route_configurations: ::prost::alloc::vec::Vec<
        super::super::super::super::super::config::route::v3::ScopedRouteConfiguration,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScopedRoutes {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub scope_key_builder: ::core::option::Option<scoped_routes::ScopeKeyBuilder>,
    #[prost(message, optional, tag = "3")]
    pub rds_config_source: ::core::option::Option<
        super::super::super::super::super::config::core::v3::ConfigSource,
    >,
    #[prost(oneof = "scoped_routes::ConfigSpecifier", tags = "4, 5")]
    pub config_specifier: ::core::option::Option<scoped_routes::ConfigSpecifier>,
}
/// Nested message and enum types in `ScopedRoutes`.
pub mod scoped_routes {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ScopeKeyBuilder {
        #[prost(message, repeated, tag = "1")]
        pub fragments: ::prost::alloc::vec::Vec<scope_key_builder::FragmentBuilder>,
    }
    /// Nested message and enum types in `ScopeKeyBuilder`.
    pub mod scope_key_builder {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FragmentBuilder {
            #[prost(oneof = "fragment_builder::Type", tags = "1")]
            pub r#type: ::core::option::Option<fragment_builder::Type>,
        }
        /// Nested message and enum types in `FragmentBuilder`.
        pub mod fragment_builder {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct HeaderValueExtractor {
                #[prost(string, tag = "1")]
                pub name: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub element_separator: ::prost::alloc::string::String,
                #[prost(oneof = "header_value_extractor::ExtractType", tags = "3, 4")]
                pub extract_type: ::core::option::Option<
                    header_value_extractor::ExtractType,
                >,
            }
            /// Nested message and enum types in `HeaderValueExtractor`.
            pub mod header_value_extractor {
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct KvElement {
                    #[prost(string, tag = "1")]
                    pub separator: ::prost::alloc::string::String,
                    #[prost(string, tag = "2")]
                    pub key: ::prost::alloc::string::String,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum ExtractType {
                    #[prost(uint32, tag = "3")]
                    Index(u32),
                    #[prost(message, tag = "4")]
                    Element(KvElement),
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Type {
                #[prost(message, tag = "1")]
                HeaderValueExtractor(HeaderValueExtractor),
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConfigSpecifier {
        #[prost(message, tag = "4")]
        ScopedRouteConfigurationsList(super::ScopedRouteConfigurationsList),
        #[prost(message, tag = "5")]
        ScopedRds(super::ScopedRds),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScopedRds {
    #[prost(message, optional, tag = "1")]
    pub scoped_rds_config_source: ::core::option::Option<
        super::super::super::super::super::config::core::v3::ConfigSource,
    >,
    #[prost(string, tag = "2")]
    pub srds_resources_locator: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpFilter {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub is_optional: bool,
    #[prost(bool, tag = "7")]
    pub disabled: bool,
    #[prost(oneof = "http_filter::ConfigType", tags = "4, 5")]
    pub config_type: ::core::option::Option<http_filter::ConfigType>,
}
/// Nested message and enum types in `HttpFilter`.
pub mod http_filter {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConfigType {
        #[prost(message, tag = "4")]
        TypedConfig(
            super::super::super::super::super::super::super::google::protobuf::Any,
        ),
        #[prost(message, tag = "5")]
        ConfigDiscovery(
            super::super::super::super::super::super::config::core::v3::ExtensionConfigSource,
        ),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestIdExtension {
    #[prost(message, optional, tag = "1")]
    pub typed_config: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Any,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnvoyMobileHttpConnectionManager {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<HttpConnectionManager>,
}
