// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rbac {
    #[prost(enumeration = "rbac::Action", tag = "1")]
    pub action: i32,
    #[prost(map = "string, message", tag = "2")]
    pub policies: ::std::collections::HashMap<::prost::alloc::string::String, Policy>,
    #[prost(message, optional, tag = "3")]
    pub audit_logging_options: ::core::option::Option<rbac::AuditLoggingOptions>,
}
/// Nested message and enum types in `RBAC`.
pub mod rbac {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AuditLoggingOptions {
        #[prost(enumeration = "audit_logging_options::AuditCondition", tag = "1")]
        pub audit_condition: i32,
        #[prost(message, repeated, tag = "2")]
        pub logger_configs: ::prost::alloc::vec::Vec<
            audit_logging_options::AuditLoggerConfig,
        >,
    }
    /// Nested message and enum types in `AuditLoggingOptions`.
    pub mod audit_logging_options {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AuditLoggerConfig {
            #[prost(message, optional, tag = "1")]
            pub audit_logger: ::core::option::Option<
                super::super::super::super::core::v3::TypedExtensionConfig,
            >,
            #[prost(bool, tag = "2")]
            pub is_optional: bool,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum AuditCondition {
            None = 0,
            OnDeny = 1,
            OnAllow = 2,
            OnDenyAndAllow = 3,
        }
        impl AuditCondition {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    AuditCondition::None => "NONE",
                    AuditCondition::OnDeny => "ON_DENY",
                    AuditCondition::OnAllow => "ON_ALLOW",
                    AuditCondition::OnDenyAndAllow => "ON_DENY_AND_ALLOW",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NONE" => Some(Self::None),
                    "ON_DENY" => Some(Self::OnDeny),
                    "ON_ALLOW" => Some(Self::OnAllow),
                    "ON_DENY_AND_ALLOW" => Some(Self::OnDenyAndAllow),
                    _ => None,
                }
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        Allow = 0,
        Deny = 1,
        Log = 2,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Action::Allow => "ALLOW",
                Action::Deny => "DENY",
                Action::Log => "LOG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALLOW" => Some(Self::Allow),
                "DENY" => Some(Self::Deny),
                "LOG" => Some(Self::Log),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Policy {
    #[prost(message, repeated, tag = "1")]
    pub permissions: ::prost::alloc::vec::Vec<Permission>,
    #[prost(message, repeated, tag = "2")]
    pub principals: ::prost::alloc::vec::Vec<Principal>,
    #[prost(message, optional, tag = "3")]
    pub condition: ::core::option::Option<
        super::super::super::super::google::api::expr::v1alpha1::Expr,
    >,
    #[prost(message, optional, tag = "4")]
    pub checked_condition: ::core::option::Option<
        super::super::super::super::google::api::expr::v1alpha1::CheckedExpr,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Permission {
    #[prost(
        oneof = "permission::Rule",
        tags = "1, 2, 3, 4, 10, 5, 6, 11, 7, 8, 9, 12, 13"
    )]
    pub rule: ::core::option::Option<permission::Rule>,
}
/// Nested message and enum types in `Permission`.
pub mod permission {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Set {
        #[prost(message, repeated, tag = "1")]
        pub rules: ::prost::alloc::vec::Vec<super::Permission>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Rule {
        #[prost(message, tag = "1")]
        AndRules(Set),
        #[prost(message, tag = "2")]
        OrRules(Set),
        #[prost(bool, tag = "3")]
        Any(bool),
        #[prost(message, tag = "4")]
        Header(super::super::super::route::v3::HeaderMatcher),
        #[prost(message, tag = "10")]
        UrlPath(super::super::super::super::r#type::matcher::v3::PathMatcher),
        #[prost(message, tag = "5")]
        DestinationIp(super::super::super::core::v3::CidrRange),
        #[prost(uint32, tag = "6")]
        DestinationPort(u32),
        #[prost(message, tag = "11")]
        DestinationPortRange(super::super::super::super::r#type::v3::Int32Range),
        #[prost(message, tag = "7")]
        Metadata(super::super::super::super::r#type::matcher::v3::MetadataMatcher),
        #[prost(message, tag = "8")]
        NotRule(::prost::alloc::boxed::Box<super::Permission>),
        #[prost(message, tag = "9")]
        RequestedServerName(
            super::super::super::super::r#type::matcher::v3::StringMatcher,
        ),
        #[prost(message, tag = "12")]
        Matcher(super::super::super::core::v3::TypedExtensionConfig),
        #[prost(message, tag = "13")]
        UriTemplate(super::super::super::core::v3::TypedExtensionConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Principal {
    #[prost(
        oneof = "principal::Identifier",
        tags = "1, 2, 3, 4, 5, 10, 11, 6, 9, 7, 12, 8"
    )]
    pub identifier: ::core::option::Option<principal::Identifier>,
}
/// Nested message and enum types in `Principal`.
pub mod principal {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Set {
        #[prost(message, repeated, tag = "1")]
        pub ids: ::prost::alloc::vec::Vec<super::Principal>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Authenticated {
        #[prost(message, optional, tag = "2")]
        pub principal_name: ::core::option::Option<
            super::super::super::super::r#type::matcher::v3::StringMatcher,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Identifier {
        #[prost(message, tag = "1")]
        AndIds(Set),
        #[prost(message, tag = "2")]
        OrIds(Set),
        #[prost(bool, tag = "3")]
        Any(bool),
        #[prost(message, tag = "4")]
        Authenticated(Authenticated),
        #[prost(message, tag = "5")]
        SourceIp(super::super::super::core::v3::CidrRange),
        #[prost(message, tag = "10")]
        DirectRemoteIp(super::super::super::core::v3::CidrRange),
        #[prost(message, tag = "11")]
        RemoteIp(super::super::super::core::v3::CidrRange),
        #[prost(message, tag = "6")]
        Header(super::super::super::route::v3::HeaderMatcher),
        #[prost(message, tag = "9")]
        UrlPath(super::super::super::super::r#type::matcher::v3::PathMatcher),
        #[prost(message, tag = "7")]
        Metadata(super::super::super::super::r#type::matcher::v3::MetadataMatcher),
        #[prost(message, tag = "12")]
        FilterState(super::super::super::super::r#type::matcher::v3::FilterStateMatcher),
        #[prost(message, tag = "8")]
        NotId(::prost::alloc::boxed::Box<super::Principal>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "rbac::Action", tag = "2")]
    pub action: i32,
}
