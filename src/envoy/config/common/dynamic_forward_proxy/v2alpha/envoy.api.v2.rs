// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterLoadAssignment {
    #[prost(string, tag = "1")]
    pub cluster_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub endpoints: ::prost::alloc::vec::Vec<endpoint::LocalityLbEndpoints>,
    #[prost(map = "string, message", tag = "5")]
    pub named_endpoints: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        endpoint::Endpoint,
    >,
    #[prost(message, optional, tag = "4")]
    pub policy: ::core::option::Option<cluster_load_assignment::Policy>,
}
/// Nested message and enum types in `ClusterLoadAssignment`.
pub mod cluster_load_assignment {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Policy {
        #[prost(message, repeated, tag = "2")]
        pub drop_overloads: ::prost::alloc::vec::Vec<policy::DropOverload>,
        #[prost(message, optional, tag = "3")]
        pub overprovisioning_factor: ::core::option::Option<
            super::super::super::super::google::protobuf::UInt32Value,
        >,
        #[prost(message, optional, tag = "4")]
        pub endpoint_stale_after: ::core::option::Option<
            super::super::super::super::google::protobuf::Duration,
        >,
        #[deprecated]
        #[prost(bool, tag = "5")]
        pub disable_overprovisioning: bool,
    }
    /// Nested message and enum types in `Policy`.
    pub mod policy {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DropOverload {
            #[prost(string, tag = "1")]
            pub category: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub drop_percentage: ::core::option::Option<
                super::super::super::super::r#type::FractionalPercent,
            >,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cluster {
    #[prost(message, repeated, tag = "43")]
    pub transport_socket_matches: ::prost::alloc::vec::Vec<
        cluster::TransportSocketMatch,
    >,
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "28")]
    pub alt_stat_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub eds_cluster_config: ::core::option::Option<cluster::EdsClusterConfig>,
    #[prost(message, optional, tag = "4")]
    pub connect_timeout: ::core::option::Option<
        super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "5")]
    pub per_connection_buffer_limit_bytes: ::core::option::Option<
        super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(enumeration = "cluster::LbPolicy", tag = "6")]
    pub lb_policy: i32,
    #[deprecated]
    #[prost(message, repeated, tag = "7")]
    pub hosts: ::prost::alloc::vec::Vec<core::Address>,
    #[prost(message, optional, tag = "33")]
    pub load_assignment: ::core::option::Option<ClusterLoadAssignment>,
    #[prost(message, repeated, tag = "8")]
    pub health_checks: ::prost::alloc::vec::Vec<core::HealthCheck>,
    #[prost(message, optional, tag = "9")]
    pub max_requests_per_connection: ::core::option::Option<
        super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(message, optional, tag = "10")]
    pub circuit_breakers: ::core::option::Option<cluster::CircuitBreakers>,
    #[deprecated]
    #[prost(message, optional, tag = "11")]
    pub tls_context: ::core::option::Option<auth::UpstreamTlsContext>,
    #[prost(message, optional, tag = "46")]
    pub upstream_http_protocol_options: ::core::option::Option<
        core::UpstreamHttpProtocolOptions,
    >,
    #[prost(message, optional, tag = "29")]
    pub common_http_protocol_options: ::core::option::Option<core::HttpProtocolOptions>,
    #[prost(message, optional, tag = "13")]
    pub http_protocol_options: ::core::option::Option<core::Http1ProtocolOptions>,
    #[prost(message, optional, tag = "14")]
    pub http2_protocol_options: ::core::option::Option<core::Http2ProtocolOptions>,
    #[prost(map = "string, message", tag = "35")]
    pub extension_protocol_options: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::super::google::protobuf::Struct,
    >,
    #[prost(map = "string, message", tag = "36")]
    pub typed_extension_protocol_options: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::super::google::protobuf::Any,
    >,
    #[prost(message, optional, tag = "16")]
    pub dns_refresh_rate: ::core::option::Option<
        super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "44")]
    pub dns_failure_refresh_rate: ::core::option::Option<cluster::RefreshRate>,
    #[prost(bool, tag = "39")]
    pub respect_dns_ttl: bool,
    #[prost(enumeration = "cluster::DnsLookupFamily", tag = "17")]
    pub dns_lookup_family: i32,
    #[prost(message, repeated, tag = "18")]
    pub dns_resolvers: ::prost::alloc::vec::Vec<core::Address>,
    #[prost(bool, tag = "45")]
    pub use_tcp_for_dns_lookups: bool,
    #[prost(message, optional, tag = "19")]
    pub outlier_detection: ::core::option::Option<cluster::OutlierDetection>,
    #[prost(message, optional, tag = "20")]
    pub cleanup_interval: ::core::option::Option<
        super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "21")]
    pub upstream_bind_config: ::core::option::Option<core::BindConfig>,
    #[prost(message, optional, tag = "22")]
    pub lb_subset_config: ::core::option::Option<cluster::LbSubsetConfig>,
    #[prost(message, optional, tag = "27")]
    pub common_lb_config: ::core::option::Option<cluster::CommonLbConfig>,
    #[prost(message, optional, tag = "24")]
    pub transport_socket: ::core::option::Option<core::TransportSocket>,
    #[prost(message, optional, tag = "25")]
    pub metadata: ::core::option::Option<core::Metadata>,
    #[prost(enumeration = "cluster::ClusterProtocolSelection", tag = "26")]
    pub protocol_selection: i32,
    #[prost(message, optional, tag = "30")]
    pub upstream_connection_options: ::core::option::Option<UpstreamConnectionOptions>,
    #[prost(bool, tag = "31")]
    pub close_connections_on_host_health_failure: bool,
    #[prost(bool, tag = "32")]
    pub drain_connections_on_host_removal: bool,
    #[prost(message, repeated, tag = "40")]
    pub filters: ::prost::alloc::vec::Vec<cluster::Filter>,
    #[prost(message, optional, tag = "41")]
    pub load_balancing_policy: ::core::option::Option<LoadBalancingPolicy>,
    #[prost(message, optional, tag = "42")]
    pub lrs_server: ::core::option::Option<core::ConfigSource>,
    #[prost(bool, tag = "47")]
    pub track_timeout_budgets: bool,
    #[prost(oneof = "cluster::ClusterDiscoveryType", tags = "2, 38")]
    pub cluster_discovery_type: ::core::option::Option<cluster::ClusterDiscoveryType>,
    #[prost(oneof = "cluster::LbConfig", tags = "23, 34, 37")]
    pub lb_config: ::core::option::Option<cluster::LbConfig>,
}
/// Nested message and enum types in `Cluster`.
pub mod cluster {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransportSocketMatch {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub r#match: ::core::option::Option<
            super::super::super::super::google::protobuf::Struct,
        >,
        #[prost(message, optional, tag = "3")]
        pub transport_socket: ::core::option::Option<super::core::TransportSocket>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CustomClusterType {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub typed_config: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EdsClusterConfig {
        #[prost(message, optional, tag = "1")]
        pub eds_config: ::core::option::Option<super::core::ConfigSource>,
        #[prost(string, tag = "2")]
        pub service_name: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LbSubsetConfig {
        #[prost(enumeration = "lb_subset_config::LbSubsetFallbackPolicy", tag = "1")]
        pub fallback_policy: i32,
        #[prost(message, optional, tag = "2")]
        pub default_subset: ::core::option::Option<
            super::super::super::super::google::protobuf::Struct,
        >,
        #[prost(message, repeated, tag = "3")]
        pub subset_selectors: ::prost::alloc::vec::Vec<
            lb_subset_config::LbSubsetSelector,
        >,
        #[prost(bool, tag = "4")]
        pub locality_weight_aware: bool,
        #[prost(bool, tag = "5")]
        pub scale_locality_weight: bool,
        #[prost(bool, tag = "6")]
        pub panic_mode_any: bool,
        #[prost(bool, tag = "7")]
        pub list_as_any: bool,
    }
    /// Nested message and enum types in `LbSubsetConfig`.
    pub mod lb_subset_config {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LbSubsetSelector {
            #[prost(string, repeated, tag = "1")]
            pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(
                enumeration = "lb_subset_selector::LbSubsetSelectorFallbackPolicy",
                tag = "2"
            )]
            pub fallback_policy: i32,
            #[prost(string, repeated, tag = "3")]
            pub fallback_keys_subset: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
        }
        /// Nested message and enum types in `LbSubsetSelector`.
        pub mod lb_subset_selector {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum LbSubsetSelectorFallbackPolicy {
                NotDefined = 0,
                NoFallback = 1,
                AnyEndpoint = 2,
                DefaultSubset = 3,
                KeysSubset = 4,
            }
            impl LbSubsetSelectorFallbackPolicy {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        LbSubsetSelectorFallbackPolicy::NotDefined => "NOT_DEFINED",
                        LbSubsetSelectorFallbackPolicy::NoFallback => "NO_FALLBACK",
                        LbSubsetSelectorFallbackPolicy::AnyEndpoint => "ANY_ENDPOINT",
                        LbSubsetSelectorFallbackPolicy::DefaultSubset => "DEFAULT_SUBSET",
                        LbSubsetSelectorFallbackPolicy::KeysSubset => "KEYS_SUBSET",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "NOT_DEFINED" => Some(Self::NotDefined),
                        "NO_FALLBACK" => Some(Self::NoFallback),
                        "ANY_ENDPOINT" => Some(Self::AnyEndpoint),
                        "DEFAULT_SUBSET" => Some(Self::DefaultSubset),
                        "KEYS_SUBSET" => Some(Self::KeysSubset),
                        _ => None,
                    }
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum LbSubsetFallbackPolicy {
            NoFallback = 0,
            AnyEndpoint = 1,
            DefaultSubset = 2,
        }
        impl LbSubsetFallbackPolicy {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    LbSubsetFallbackPolicy::NoFallback => "NO_FALLBACK",
                    LbSubsetFallbackPolicy::AnyEndpoint => "ANY_ENDPOINT",
                    LbSubsetFallbackPolicy::DefaultSubset => "DEFAULT_SUBSET",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NO_FALLBACK" => Some(Self::NoFallback),
                    "ANY_ENDPOINT" => Some(Self::AnyEndpoint),
                    "DEFAULT_SUBSET" => Some(Self::DefaultSubset),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct LeastRequestLbConfig {
        #[prost(message, optional, tag = "1")]
        pub choice_count: ::core::option::Option<
            super::super::super::super::google::protobuf::UInt32Value,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RingHashLbConfig {
        #[prost(message, optional, tag = "1")]
        pub minimum_ring_size: ::core::option::Option<
            super::super::super::super::google::protobuf::UInt64Value,
        >,
        #[prost(enumeration = "ring_hash_lb_config::HashFunction", tag = "3")]
        pub hash_function: i32,
        #[prost(message, optional, tag = "4")]
        pub maximum_ring_size: ::core::option::Option<
            super::super::super::super::google::protobuf::UInt64Value,
        >,
    }
    /// Nested message and enum types in `RingHashLbConfig`.
    pub mod ring_hash_lb_config {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum HashFunction {
            XxHash = 0,
            MurmurHash2 = 1,
        }
        impl HashFunction {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    HashFunction::XxHash => "XX_HASH",
                    HashFunction::MurmurHash2 => "MURMUR_HASH_2",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "XX_HASH" => Some(Self::XxHash),
                    "MURMUR_HASH_2" => Some(Self::MurmurHash2),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct OriginalDstLbConfig {
        #[prost(bool, tag = "1")]
        pub use_http_header: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CommonLbConfig {
        #[prost(message, optional, tag = "1")]
        pub healthy_panic_threshold: ::core::option::Option<
            super::super::super::r#type::Percent,
        >,
        #[prost(message, optional, tag = "4")]
        pub update_merge_window: ::core::option::Option<
            super::super::super::super::google::protobuf::Duration,
        >,
        #[prost(bool, tag = "5")]
        pub ignore_new_hosts_until_first_hc: bool,
        #[prost(bool, tag = "6")]
        pub close_connections_on_host_set_change: bool,
        #[prost(message, optional, tag = "7")]
        pub consistent_hashing_lb_config: ::core::option::Option<
            common_lb_config::ConsistentHashingLbConfig,
        >,
        #[prost(oneof = "common_lb_config::LocalityConfigSpecifier", tags = "2, 3")]
        pub locality_config_specifier: ::core::option::Option<
            common_lb_config::LocalityConfigSpecifier,
        >,
    }
    /// Nested message and enum types in `CommonLbConfig`.
    pub mod common_lb_config {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ZoneAwareLbConfig {
            #[prost(message, optional, tag = "1")]
            pub routing_enabled: ::core::option::Option<
                super::super::super::super::r#type::Percent,
            >,
            #[prost(message, optional, tag = "2")]
            pub min_cluster_size: ::core::option::Option<
                super::super::super::super::super::google::protobuf::UInt64Value,
            >,
            #[prost(bool, tag = "3")]
            pub fail_traffic_on_panic: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct LocalityWeightedLbConfig {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ConsistentHashingLbConfig {
            #[prost(bool, tag = "1")]
            pub use_hostname_for_hashing: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum LocalityConfigSpecifier {
            #[prost(message, tag = "2")]
            ZoneAwareLbConfig(ZoneAwareLbConfig),
            #[prost(message, tag = "3")]
            LocalityWeightedLbConfig(LocalityWeightedLbConfig),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RefreshRate {
        #[prost(message, optional, tag = "1")]
        pub base_interval: ::core::option::Option<
            super::super::super::super::google::protobuf::Duration,
        >,
        #[prost(message, optional, tag = "2")]
        pub max_interval: ::core::option::Option<
            super::super::super::super::google::protobuf::Duration,
        >,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DiscoveryType {
        Static = 0,
        StrictDns = 1,
        LogicalDns = 2,
        Eds = 3,
        OriginalDst = 4,
    }
    impl DiscoveryType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DiscoveryType::Static => "STATIC",
                DiscoveryType::StrictDns => "STRICT_DNS",
                DiscoveryType::LogicalDns => "LOGICAL_DNS",
                DiscoveryType::Eds => "EDS",
                DiscoveryType::OriginalDst => "ORIGINAL_DST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATIC" => Some(Self::Static),
                "STRICT_DNS" => Some(Self::StrictDns),
                "LOGICAL_DNS" => Some(Self::LogicalDns),
                "EDS" => Some(Self::Eds),
                "ORIGINAL_DST" => Some(Self::OriginalDst),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LbPolicy {
        RoundRobin = 0,
        LeastRequest = 1,
        RingHash = 2,
        Random = 3,
        OriginalDstLb = 4,
        Maglev = 5,
        ClusterProvided = 6,
        LoadBalancingPolicyConfig = 7,
    }
    impl LbPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LbPolicy::RoundRobin => "ROUND_ROBIN",
                LbPolicy::LeastRequest => "LEAST_REQUEST",
                LbPolicy::RingHash => "RING_HASH",
                LbPolicy::Random => "RANDOM",
                LbPolicy::OriginalDstLb => "ORIGINAL_DST_LB",
                LbPolicy::Maglev => "MAGLEV",
                LbPolicy::ClusterProvided => "CLUSTER_PROVIDED",
                LbPolicy::LoadBalancingPolicyConfig => "LOAD_BALANCING_POLICY_CONFIG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROUND_ROBIN" => Some(Self::RoundRobin),
                "LEAST_REQUEST" => Some(Self::LeastRequest),
                "RING_HASH" => Some(Self::RingHash),
                "RANDOM" => Some(Self::Random),
                "ORIGINAL_DST_LB" => Some(Self::OriginalDstLb),
                "MAGLEV" => Some(Self::Maglev),
                "CLUSTER_PROVIDED" => Some(Self::ClusterProvided),
                "LOAD_BALANCING_POLICY_CONFIG" => Some(Self::LoadBalancingPolicyConfig),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DnsLookupFamily {
        Auto = 0,
        V4Only = 1,
        V6Only = 2,
    }
    impl DnsLookupFamily {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DnsLookupFamily::Auto => "AUTO",
                DnsLookupFamily::V4Only => "V4_ONLY",
                DnsLookupFamily::V6Only => "V6_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUTO" => Some(Self::Auto),
                "V4_ONLY" => Some(Self::V4Only),
                "V6_ONLY" => Some(Self::V6Only),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClusterProtocolSelection {
        UseConfiguredProtocol = 0,
        UseDownstreamProtocol = 1,
    }
    impl ClusterProtocolSelection {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ClusterProtocolSelection::UseConfiguredProtocol => {
                    "USE_CONFIGURED_PROTOCOL"
                }
                ClusterProtocolSelection::UseDownstreamProtocol => {
                    "USE_DOWNSTREAM_PROTOCOL"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "USE_CONFIGURED_PROTOCOL" => Some(Self::UseConfiguredProtocol),
                "USE_DOWNSTREAM_PROTOCOL" => Some(Self::UseDownstreamProtocol),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ClusterDiscoveryType {
        #[prost(enumeration = "DiscoveryType", tag = "2")]
        Type(i32),
        #[prost(message, tag = "38")]
        ClusterType(CustomClusterType),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LbConfig {
        #[prost(message, tag = "23")]
        RingHashLbConfig(RingHashLbConfig),
        #[prost(message, tag = "34")]
        OriginalDstLbConfig(OriginalDstLbConfig),
        #[prost(message, tag = "37")]
        LeastRequestLbConfig(LeastRequestLbConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadBalancingPolicy {
    #[prost(message, repeated, tag = "1")]
    pub policies: ::prost::alloc::vec::Vec<load_balancing_policy::Policy>,
}
/// Nested message and enum types in `LoadBalancingPolicy`.
pub mod load_balancing_policy {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Policy {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[deprecated]
        #[prost(message, optional, tag = "2")]
        pub config: ::core::option::Option<
            super::super::super::super::google::protobuf::Struct,
        >,
        #[prost(message, optional, tag = "3")]
        pub typed_config: ::core::option::Option<
            super::super::super::super::google::protobuf::Any,
        >,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpstreamBindConfig {
    #[prost(message, optional, tag = "1")]
    pub source_address: ::core::option::Option<core::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpstreamConnectionOptions {
    #[prost(message, optional, tag = "1")]
    pub tcp_keepalive: ::core::option::Option<core::TcpKeepalive>,
}
