// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParsedExpr {
    #[prost(message, optional, tag = "2")]
    pub expr: ::core::option::Option<Expr>,
    #[prost(message, optional, tag = "3")]
    pub source_info: ::core::option::Option<SourceInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Expr {
    #[prost(int64, tag = "2")]
    pub id: i64,
    #[prost(oneof = "expr::ExprKind", tags = "3, 4, 5, 6, 7, 8, 9")]
    pub expr_kind: ::core::option::Option<expr::ExprKind>,
}
/// Nested message and enum types in `Expr`.
pub mod expr {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Ident {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Select {
        #[prost(message, optional, boxed, tag = "1")]
        pub operand: ::core::option::Option<::prost::alloc::boxed::Box<super::Expr>>,
        #[prost(string, tag = "2")]
        pub field: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub test_only: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Call {
        #[prost(message, optional, boxed, tag = "1")]
        pub target: ::core::option::Option<::prost::alloc::boxed::Box<super::Expr>>,
        #[prost(string, tag = "2")]
        pub function: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub args: ::prost::alloc::vec::Vec<super::Expr>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreateList {
        #[prost(message, repeated, tag = "1")]
        pub elements: ::prost::alloc::vec::Vec<super::Expr>,
        #[prost(int32, repeated, tag = "2")]
        pub optional_indices: ::prost::alloc::vec::Vec<i32>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreateStruct {
        #[prost(string, tag = "1")]
        pub message_name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub entries: ::prost::alloc::vec::Vec<create_struct::Entry>,
    }
    /// Nested message and enum types in `CreateStruct`.
    pub mod create_struct {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Entry {
            #[prost(int64, tag = "1")]
            pub id: i64,
            #[prost(message, optional, tag = "4")]
            pub value: ::core::option::Option<super::super::Expr>,
            #[prost(bool, tag = "5")]
            pub optional_entry: bool,
            #[prost(oneof = "entry::KeyKind", tags = "2, 3")]
            pub key_kind: ::core::option::Option<entry::KeyKind>,
        }
        /// Nested message and enum types in `Entry`.
        pub mod entry {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum KeyKind {
                #[prost(string, tag = "2")]
                FieldKey(::prost::alloc::string::String),
                #[prost(message, tag = "3")]
                MapKey(super::super::super::Expr),
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Comprehension {
        #[prost(string, tag = "1")]
        pub iter_var: ::prost::alloc::string::String,
        #[prost(string, tag = "8")]
        pub iter_var2: ::prost::alloc::string::String,
        #[prost(message, optional, boxed, tag = "2")]
        pub iter_range: ::core::option::Option<::prost::alloc::boxed::Box<super::Expr>>,
        #[prost(string, tag = "3")]
        pub accu_var: ::prost::alloc::string::String,
        #[prost(message, optional, boxed, tag = "4")]
        pub accu_init: ::core::option::Option<::prost::alloc::boxed::Box<super::Expr>>,
        #[prost(message, optional, boxed, tag = "5")]
        pub loop_condition: ::core::option::Option<
            ::prost::alloc::boxed::Box<super::Expr>,
        >,
        #[prost(message, optional, boxed, tag = "6")]
        pub loop_step: ::core::option::Option<::prost::alloc::boxed::Box<super::Expr>>,
        #[prost(message, optional, boxed, tag = "7")]
        pub result: ::core::option::Option<::prost::alloc::boxed::Box<super::Expr>>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ExprKind {
        #[prost(message, tag = "3")]
        ConstExpr(super::Constant),
        #[prost(message, tag = "4")]
        IdentExpr(Ident),
        #[prost(message, tag = "5")]
        SelectExpr(::prost::alloc::boxed::Box<Select>),
        #[prost(message, tag = "6")]
        CallExpr(::prost::alloc::boxed::Box<Call>),
        #[prost(message, tag = "7")]
        ListExpr(CreateList),
        #[prost(message, tag = "8")]
        StructExpr(CreateStruct),
        #[prost(message, tag = "9")]
        ComprehensionExpr(::prost::alloc::boxed::Box<Comprehension>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Constant {
    #[prost(oneof = "constant::ConstantKind", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9")]
    pub constant_kind: ::core::option::Option<constant::ConstantKind>,
}
/// Nested message and enum types in `Constant`.
pub mod constant {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConstantKind {
        #[prost(
            enumeration = "super::super::super::super::protobuf::NullValue",
            tag = "1"
        )]
        NullValue(i32),
        #[prost(bool, tag = "2")]
        BoolValue(bool),
        #[prost(int64, tag = "3")]
        Int64Value(i64),
        #[prost(uint64, tag = "4")]
        Uint64Value(u64),
        #[prost(double, tag = "5")]
        DoubleValue(f64),
        #[prost(string, tag = "6")]
        StringValue(::prost::alloc::string::String),
        #[prost(bytes, tag = "7")]
        BytesValue(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "8")]
        DurationValue(super::super::super::super::protobuf::Duration),
        #[prost(message, tag = "9")]
        TimestampValue(super::super::super::super::protobuf::Timestamp),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceInfo {
    #[prost(string, tag = "1")]
    pub syntax_version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub location: ::prost::alloc::string::String,
    #[prost(int32, repeated, tag = "3")]
    pub line_offsets: ::prost::alloc::vec::Vec<i32>,
    #[prost(map = "int64, int32", tag = "4")]
    pub positions: ::std::collections::HashMap<i64, i32>,
    #[prost(map = "int64, message", tag = "5")]
    pub macro_calls: ::std::collections::HashMap<i64, Expr>,
    #[prost(message, repeated, tag = "6")]
    pub extensions: ::prost::alloc::vec::Vec<source_info::Extension>,
}
/// Nested message and enum types in `SourceInfo`.
pub mod source_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Extension {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(enumeration = "extension::Component", repeated, tag = "2")]
        pub affected_components: ::prost::alloc::vec::Vec<i32>,
        #[prost(message, optional, tag = "3")]
        pub version: ::core::option::Option<extension::Version>,
    }
    /// Nested message and enum types in `Extension`.
    pub mod extension {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Version {
            #[prost(int64, tag = "1")]
            pub major: i64,
            #[prost(int64, tag = "2")]
            pub minor: i64,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Component {
            Unspecified = 0,
            Parser = 1,
            TypeChecker = 2,
            Runtime = 3,
        }
        impl Component {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Component::Unspecified => "COMPONENT_UNSPECIFIED",
                    Component::Parser => "COMPONENT_PARSER",
                    Component::TypeChecker => "COMPONENT_TYPE_CHECKER",
                    Component::Runtime => "COMPONENT_RUNTIME",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "COMPONENT_UNSPECIFIED" => Some(Self::Unspecified),
                    "COMPONENT_PARSER" => Some(Self::Parser),
                    "COMPONENT_TYPE_CHECKER" => Some(Self::TypeChecker),
                    "COMPONENT_RUNTIME" => Some(Self::Runtime),
                    _ => None,
                }
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourcePosition {
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub offset: i32,
    #[prost(int32, tag = "3")]
    pub line: i32,
    #[prost(int32, tag = "4")]
    pub column: i32,
}
