// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteConfiguration {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub routes: ::prost::alloc::vec::Vec<Route>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Route {
    #[prost(message, optional, tag = "1")]
    pub r#match: ::core::option::Option<RouteMatch>,
    #[prost(message, optional, tag = "2")]
    pub route: ::core::option::Option<RouteAction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteMatch {
    #[prost(bool, tag = "3")]
    pub invert: bool,
    #[prost(message, repeated, tag = "4")]
    pub headers: ::prost::alloc::vec::Vec<
        super::super::super::super::super::api::v2::route::HeaderMatcher,
    >,
    #[prost(oneof = "route_match::MatchSpecifier", tags = "1, 2")]
    pub match_specifier: ::core::option::Option<route_match::MatchSpecifier>,
}
/// Nested message and enum types in `RouteMatch`.
pub mod route_match {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MatchSpecifier {
        #[prost(string, tag = "1")]
        MethodName(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        ServiceName(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteAction {
    #[prost(message, optional, tag = "3")]
    pub metadata_match: ::core::option::Option<
        super::super::super::super::super::api::v2::core::Metadata,
    >,
    #[prost(message, repeated, tag = "4")]
    pub rate_limits: ::prost::alloc::vec::Vec<
        super::super::super::super::super::api::v2::route::RateLimit,
    >,
    #[prost(bool, tag = "5")]
    pub strip_service_name: bool,
    #[prost(oneof = "route_action::ClusterSpecifier", tags = "1, 2, 6")]
    pub cluster_specifier: ::core::option::Option<route_action::ClusterSpecifier>,
}
/// Nested message and enum types in `RouteAction`.
pub mod route_action {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ClusterSpecifier {
        #[prost(string, tag = "1")]
        Cluster(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        WeightedClusters(super::WeightedCluster),
        #[prost(string, tag = "6")]
        ClusterHeader(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeightedCluster {
    #[prost(message, repeated, tag = "1")]
    pub clusters: ::prost::alloc::vec::Vec<weighted_cluster::ClusterWeight>,
}
/// Nested message and enum types in `WeightedCluster`.
pub mod weighted_cluster {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClusterWeight {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub weight: ::core::option::Option<
            super::super::super::super::super::super::super::google::protobuf::UInt32Value,
        >,
        #[prost(message, optional, tag = "3")]
        pub metadata_match: ::core::option::Option<
            super::super::super::super::super::super::api::v2::core::Metadata,
        >,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThriftProxy {
    #[prost(enumeration = "TransportType", tag = "2")]
    pub transport: i32,
    #[prost(enumeration = "ProtocolType", tag = "3")]
    pub protocol: i32,
    #[prost(string, tag = "1")]
    pub stat_prefix: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub route_config: ::core::option::Option<RouteConfiguration>,
    #[prost(message, repeated, tag = "5")]
    pub thrift_filters: ::prost::alloc::vec::Vec<ThriftFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThriftFilter {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "thrift_filter::ConfigType", tags = "2, 3")]
    pub config_type: ::core::option::Option<thrift_filter::ConfigType>,
}
/// Nested message and enum types in `ThriftFilter`.
pub mod thrift_filter {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConfigType {
        #[prost(message, tag = "2")]
        Config(
            super::super::super::super::super::super::super::google::protobuf::Struct,
        ),
        #[prost(message, tag = "3")]
        TypedConfig(
            super::super::super::super::super::super::super::google::protobuf::Any,
        ),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ThriftProtocolOptions {
    #[prost(enumeration = "TransportType", tag = "1")]
    pub transport: i32,
    #[prost(enumeration = "ProtocolType", tag = "2")]
    pub protocol: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransportType {
    AutoTransport = 0,
    Framed = 1,
    Unframed = 2,
    Header = 3,
}
impl TransportType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TransportType::AutoTransport => "AUTO_TRANSPORT",
            TransportType::Framed => "FRAMED",
            TransportType::Unframed => "UNFRAMED",
            TransportType::Header => "HEADER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUTO_TRANSPORT" => Some(Self::AutoTransport),
            "FRAMED" => Some(Self::Framed),
            "UNFRAMED" => Some(Self::Unframed),
            "HEADER" => Some(Self::Header),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProtocolType {
    AutoProtocol = 0,
    Binary = 1,
    LaxBinary = 2,
    Compact = 3,
    Twitter = 4,
}
impl ProtocolType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProtocolType::AutoProtocol => "AUTO_PROTOCOL",
            ProtocolType::Binary => "BINARY",
            ProtocolType::LaxBinary => "LAX_BINARY",
            ProtocolType::Compact => "COMPACT",
            ProtocolType::Twitter => "TWITTER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUTO_PROTOCOL" => Some(Self::AutoProtocol),
            "BINARY" => Some(Self::Binary),
            "LAX_BINARY" => Some(Self::LaxBinary),
            "COMPACT" => Some(Self::Compact),
            "TWITTER" => Some(Self::Twitter),
            _ => None,
        }
    }
}
