// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedisProxy {
    #[prost(string, tag = "1")]
    pub stat_prefix: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "2")]
    pub cluster: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub settings: ::core::option::Option<redis_proxy::ConnPoolSettings>,
    #[prost(bool, tag = "4")]
    pub latency_in_micros: bool,
    #[prost(message, optional, tag = "5")]
    pub prefix_routes: ::core::option::Option<redis_proxy::PrefixRoutes>,
    #[prost(message, optional, tag = "6")]
    pub downstream_auth_password: ::core::option::Option<
        super::super::super::super::super::api::v2::core::DataSource,
    >,
}
/// Nested message and enum types in `RedisProxy`.
pub mod redis_proxy {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ConnPoolSettings {
        #[prost(message, optional, tag = "1")]
        pub op_timeout: ::core::option::Option<
            super::super::super::super::super::super::super::google::protobuf::Duration,
        >,
        #[prost(bool, tag = "2")]
        pub enable_hashtagging: bool,
        #[prost(bool, tag = "3")]
        pub enable_redirection: bool,
        #[prost(uint32, tag = "4")]
        pub max_buffer_size_before_flush: u32,
        #[prost(message, optional, tag = "5")]
        pub buffer_flush_timeout: ::core::option::Option<
            super::super::super::super::super::super::super::google::protobuf::Duration,
        >,
        #[prost(message, optional, tag = "6")]
        pub max_upstream_unknown_connections: ::core::option::Option<
            super::super::super::super::super::super::super::google::protobuf::UInt32Value,
        >,
        #[prost(bool, tag = "8")]
        pub enable_command_stats: bool,
        #[prost(enumeration = "conn_pool_settings::ReadPolicy", tag = "7")]
        pub read_policy: i32,
    }
    /// Nested message and enum types in `ConnPoolSettings`.
    pub mod conn_pool_settings {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ReadPolicy {
            Master = 0,
            PreferMaster = 1,
            Replica = 2,
            PreferReplica = 3,
            Any = 4,
        }
        impl ReadPolicy {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ReadPolicy::Master => "MASTER",
                    ReadPolicy::PreferMaster => "PREFER_MASTER",
                    ReadPolicy::Replica => "REPLICA",
                    ReadPolicy::PreferReplica => "PREFER_REPLICA",
                    ReadPolicy::Any => "ANY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MASTER" => Some(Self::Master),
                    "PREFER_MASTER" => Some(Self::PreferMaster),
                    "REPLICA" => Some(Self::Replica),
                    "PREFER_REPLICA" => Some(Self::PreferReplica),
                    "ANY" => Some(Self::Any),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PrefixRoutes {
        #[prost(message, repeated, tag = "1")]
        pub routes: ::prost::alloc::vec::Vec<prefix_routes::Route>,
        #[prost(bool, tag = "2")]
        pub case_insensitive: bool,
        #[deprecated]
        #[prost(string, tag = "3")]
        pub catch_all_cluster: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub catch_all_route: ::core::option::Option<prefix_routes::Route>,
    }
    /// Nested message and enum types in `PrefixRoutes`.
    pub mod prefix_routes {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Route {
            #[prost(string, tag = "1")]
            pub prefix: ::prost::alloc::string::String,
            #[prost(bool, tag = "2")]
            pub remove_prefix: bool,
            #[prost(string, tag = "3")]
            pub cluster: ::prost::alloc::string::String,
            #[prost(message, repeated, tag = "4")]
            pub request_mirror_policy: ::prost::alloc::vec::Vec<
                route::RequestMirrorPolicy,
            >,
        }
        /// Nested message and enum types in `Route`.
        pub mod route {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct RequestMirrorPolicy {
                #[prost(string, tag = "1")]
                pub cluster: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub runtime_fraction: ::core::option::Option<
                    super::super::super::super::super::super::super::super::api::v2::core::RuntimeFractionalPercent,
                >,
                #[prost(bool, tag = "3")]
                pub exclude_read_commands: bool,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedisProtocolOptions {
    #[prost(message, optional, tag = "1")]
    pub auth_password: ::core::option::Option<
        super::super::super::super::super::api::v2::core::DataSource,
    >,
}
