// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpConnectionManager {
    #[prost(enumeration = "http_connection_manager::CodecType", tag = "1")]
    pub codec_type: i32,
    #[prost(string, tag = "2")]
    pub stat_prefix: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub http_filters: ::prost::alloc::vec::Vec<HttpFilter>,
    #[prost(message, optional, tag = "6")]
    pub add_user_agent: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(message, optional, tag = "7")]
    pub tracing: ::core::option::Option<http_connection_manager::Tracing>,
    #[prost(message, optional, tag = "35")]
    pub common_http_protocol_options: ::core::option::Option<
        super::super::super::super::super::api::v2::core::HttpProtocolOptions,
    >,
    #[prost(message, optional, tag = "8")]
    pub http_protocol_options: ::core::option::Option<
        super::super::super::super::super::api::v2::core::Http1ProtocolOptions,
    >,
    #[prost(message, optional, tag = "9")]
    pub http2_protocol_options: ::core::option::Option<
        super::super::super::super::super::api::v2::core::Http2ProtocolOptions,
    >,
    #[prost(string, tag = "10")]
    pub server_name: ::prost::alloc::string::String,
    #[prost(
        enumeration = "http_connection_manager::ServerHeaderTransformation",
        tag = "34"
    )]
    pub server_header_transformation: i32,
    #[prost(message, optional, tag = "29")]
    pub max_request_headers_kb: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::UInt32Value,
    >,
    #[deprecated]
    #[prost(message, optional, tag = "11")]
    pub idle_timeout: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "24")]
    pub stream_idle_timeout: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "28")]
    pub request_timeout: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "12")]
    pub drain_timeout: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, optional, tag = "26")]
    pub delayed_close_timeout: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(message, repeated, tag = "13")]
    pub access_log: ::prost::alloc::vec::Vec<
        super::super::super::accesslog::v2::AccessLog,
    >,
    #[prost(message, optional, tag = "14")]
    pub use_remote_address: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(uint32, tag = "19")]
    pub xff_num_trusted_hops: u32,
    #[prost(message, optional, tag = "25")]
    pub internal_address_config: ::core::option::Option<
        http_connection_manager::InternalAddressConfig,
    >,
    #[prost(bool, tag = "21")]
    pub skip_xff_append: bool,
    #[prost(string, tag = "22")]
    pub via: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "15")]
    pub generate_request_id: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(bool, tag = "32")]
    pub preserve_external_request_id: bool,
    #[prost(
        enumeration = "http_connection_manager::ForwardClientCertDetails",
        tag = "16"
    )]
    pub forward_client_cert_details: i32,
    #[prost(message, optional, tag = "17")]
    pub set_current_client_cert_details: ::core::option::Option<
        http_connection_manager::SetCurrentClientCertDetails,
    >,
    #[prost(bool, tag = "18")]
    pub proxy_100_continue: bool,
    #[prost(bool, tag = "20")]
    pub represent_ipv4_remote_address_as_ipv4_mapped_ipv6: bool,
    #[prost(message, repeated, tag = "23")]
    pub upgrade_configs: ::prost::alloc::vec::Vec<
        http_connection_manager::UpgradeConfig,
    >,
    #[prost(message, optional, tag = "30")]
    pub normalize_path: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(bool, tag = "33")]
    pub merge_slashes: bool,
    #[prost(message, optional, tag = "36")]
    pub request_id_extension: ::core::option::Option<RequestIdExtension>,
    #[prost(oneof = "http_connection_manager::RouteSpecifier", tags = "3, 4, 31")]
    pub route_specifier: ::core::option::Option<http_connection_manager::RouteSpecifier>,
}
/// Nested message and enum types in `HttpConnectionManager`.
pub mod http_connection_manager {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Tracing {
        #[deprecated]
        #[prost(enumeration = "tracing::OperationName", tag = "1")]
        pub operation_name: i32,
        #[deprecated]
        #[prost(string, repeated, tag = "2")]
        pub request_headers_for_tags: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        #[prost(message, optional, tag = "3")]
        pub client_sampling: ::core::option::Option<
            super::super::super::super::super::super::r#type::Percent,
        >,
        #[prost(message, optional, tag = "4")]
        pub random_sampling: ::core::option::Option<
            super::super::super::super::super::super::r#type::Percent,
        >,
        #[prost(message, optional, tag = "5")]
        pub overall_sampling: ::core::option::Option<
            super::super::super::super::super::super::r#type::Percent,
        >,
        #[prost(bool, tag = "6")]
        pub verbose: bool,
        #[prost(message, optional, tag = "7")]
        pub max_path_tag_length: ::core::option::Option<
            super::super::super::super::super::super::super::google::protobuf::UInt32Value,
        >,
        #[prost(message, repeated, tag = "8")]
        pub custom_tags: ::prost::alloc::vec::Vec<
            super::super::super::super::super::super::r#type::tracing::v2::CustomTag,
        >,
        #[prost(message, optional, tag = "9")]
        pub provider: ::core::option::Option<
            super::super::super::super::super::trace::v2::tracing::Http,
        >,
    }
    /// Nested message and enum types in `Tracing`.
    pub mod tracing {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum OperationName {
            Ingress = 0,
            Egress = 1,
        }
        impl OperationName {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    OperationName::Ingress => "INGRESS",
                    OperationName::Egress => "EGRESS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "INGRESS" => Some(Self::Ingress),
                    "EGRESS" => Some(Self::Egress),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct InternalAddressConfig {
        #[prost(bool, tag = "1")]
        pub unix_sockets: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SetCurrentClientCertDetails {
        #[prost(message, optional, tag = "1")]
        pub subject: ::core::option::Option<
            super::super::super::super::super::super::super::google::protobuf::BoolValue,
        >,
        #[prost(bool, tag = "3")]
        pub cert: bool,
        #[prost(bool, tag = "6")]
        pub chain: bool,
        #[prost(bool, tag = "4")]
        pub dns: bool,
        #[prost(bool, tag = "5")]
        pub uri: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpgradeConfig {
        #[prost(string, tag = "1")]
        pub upgrade_type: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub filters: ::prost::alloc::vec::Vec<super::HttpFilter>,
        #[prost(message, optional, tag = "3")]
        pub enabled: ::core::option::Option<
            super::super::super::super::super::super::super::google::protobuf::BoolValue,
        >,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CodecType {
        Auto = 0,
        Http1 = 1,
        Http2 = 2,
        Http3 = 3,
    }
    impl CodecType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CodecType::Auto => "AUTO",
                CodecType::Http1 => "HTTP1",
                CodecType::Http2 => "HTTP2",
                CodecType::Http3 => "HTTP3",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUTO" => Some(Self::Auto),
                "HTTP1" => Some(Self::Http1),
                "HTTP2" => Some(Self::Http2),
                "HTTP3" => Some(Self::Http3),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ServerHeaderTransformation {
        Overwrite = 0,
        AppendIfAbsent = 1,
        PassThrough = 2,
    }
    impl ServerHeaderTransformation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ServerHeaderTransformation::Overwrite => "OVERWRITE",
                ServerHeaderTransformation::AppendIfAbsent => "APPEND_IF_ABSENT",
                ServerHeaderTransformation::PassThrough => "PASS_THROUGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OVERWRITE" => Some(Self::Overwrite),
                "APPEND_IF_ABSENT" => Some(Self::AppendIfAbsent),
                "PASS_THROUGH" => Some(Self::PassThrough),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ForwardClientCertDetails {
        Sanitize = 0,
        ForwardOnly = 1,
        AppendForward = 2,
        SanitizeSet = 3,
        AlwaysForwardOnly = 4,
    }
    impl ForwardClientCertDetails {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ForwardClientCertDetails::Sanitize => "SANITIZE",
                ForwardClientCertDetails::ForwardOnly => "FORWARD_ONLY",
                ForwardClientCertDetails::AppendForward => "APPEND_FORWARD",
                ForwardClientCertDetails::SanitizeSet => "SANITIZE_SET",
                ForwardClientCertDetails::AlwaysForwardOnly => "ALWAYS_FORWARD_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SANITIZE" => Some(Self::Sanitize),
                "FORWARD_ONLY" => Some(Self::ForwardOnly),
                "APPEND_FORWARD" => Some(Self::AppendForward),
                "SANITIZE_SET" => Some(Self::SanitizeSet),
                "ALWAYS_FORWARD_ONLY" => Some(Self::AlwaysForwardOnly),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RouteSpecifier {
        #[prost(message, tag = "3")]
        Rds(super::Rds),
        #[prost(message, tag = "4")]
        RouteConfig(
            super::super::super::super::super::super::api::v2::RouteConfiguration,
        ),
        #[prost(message, tag = "31")]
        ScopedRoutes(super::ScopedRoutes),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rds {
    #[prost(message, optional, tag = "1")]
    pub config_source: ::core::option::Option<
        super::super::super::super::super::api::v2::core::ConfigSource,
    >,
    #[prost(string, tag = "2")]
    pub route_config_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScopedRouteConfigurationsList {
    #[prost(message, repeated, tag = "1")]
    pub scoped_route_configurations: ::prost::alloc::vec::Vec<
        super::super::super::super::super::api::v2::ScopedRouteConfiguration,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScopedRoutes {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub scope_key_builder: ::core::option::Option<scoped_routes::ScopeKeyBuilder>,
    #[prost(message, optional, tag = "3")]
    pub rds_config_source: ::core::option::Option<
        super::super::super::super::super::api::v2::core::ConfigSource,
    >,
    #[prost(oneof = "scoped_routes::ConfigSpecifier", tags = "4, 5")]
    pub config_specifier: ::core::option::Option<scoped_routes::ConfigSpecifier>,
}
/// Nested message and enum types in `ScopedRoutes`.
pub mod scoped_routes {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ScopeKeyBuilder {
        #[prost(message, repeated, tag = "1")]
        pub fragments: ::prost::alloc::vec::Vec<scope_key_builder::FragmentBuilder>,
    }
    /// Nested message and enum types in `ScopeKeyBuilder`.
    pub mod scope_key_builder {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FragmentBuilder {
            #[prost(oneof = "fragment_builder::Type", tags = "1")]
            pub r#type: ::core::option::Option<fragment_builder::Type>,
        }
        /// Nested message and enum types in `FragmentBuilder`.
        pub mod fragment_builder {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct HeaderValueExtractor {
                #[prost(string, tag = "1")]
                pub name: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub element_separator: ::prost::alloc::string::String,
                #[prost(oneof = "header_value_extractor::ExtractType", tags = "3, 4")]
                pub extract_type: ::core::option::Option<
                    header_value_extractor::ExtractType,
                >,
            }
            /// Nested message and enum types in `HeaderValueExtractor`.
            pub mod header_value_extractor {
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct KvElement {
                    #[prost(string, tag = "1")]
                    pub separator: ::prost::alloc::string::String,
                    #[prost(string, tag = "2")]
                    pub key: ::prost::alloc::string::String,
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum ExtractType {
                    #[prost(uint32, tag = "3")]
                    Index(u32),
                    #[prost(message, tag = "4")]
                    Element(KvElement),
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Type {
                #[prost(message, tag = "1")]
                HeaderValueExtractor(HeaderValueExtractor),
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConfigSpecifier {
        #[prost(message, tag = "4")]
        ScopedRouteConfigurationsList(super::ScopedRouteConfigurationsList),
        #[prost(message, tag = "5")]
        ScopedRds(super::ScopedRds),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScopedRds {
    #[prost(message, optional, tag = "1")]
    pub scoped_rds_config_source: ::core::option::Option<
        super::super::super::super::super::api::v2::core::ConfigSource,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpFilter {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "http_filter::ConfigType", tags = "2, 4")]
    pub config_type: ::core::option::Option<http_filter::ConfigType>,
}
/// Nested message and enum types in `HttpFilter`.
pub mod http_filter {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConfigType {
        #[prost(message, tag = "2")]
        Config(
            super::super::super::super::super::super::super::google::protobuf::Struct,
        ),
        #[prost(message, tag = "4")]
        TypedConfig(
            super::super::super::super::super::super::super::google::protobuf::Any,
        ),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestIdExtension {
    #[prost(message, optional, tag = "1")]
    pub typed_config: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Any,
    >,
}
