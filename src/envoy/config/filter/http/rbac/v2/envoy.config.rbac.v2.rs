// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rbac {
    #[prost(enumeration = "rbac::Action", tag = "1")]
    pub action: i32,
    #[prost(map = "string, message", tag = "2")]
    pub policies: ::std::collections::HashMap<::prost::alloc::string::String, Policy>,
}
/// Nested message and enum types in `RBAC`.
pub mod rbac {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        Allow = 0,
        Deny = 1,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Action::Allow => "ALLOW",
                Action::Deny => "DENY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALLOW" => Some(Self::Allow),
                "DENY" => Some(Self::Deny),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Policy {
    #[prost(message, repeated, tag = "1")]
    pub permissions: ::prost::alloc::vec::Vec<Permission>,
    #[prost(message, repeated, tag = "2")]
    pub principals: ::prost::alloc::vec::Vec<Principal>,
    #[prost(message, optional, tag = "3")]
    pub condition: ::core::option::Option<
        super::super::super::super::google::api::expr::v1alpha1::Expr,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Permission {
    #[prost(oneof = "permission::Rule", tags = "1, 2, 3, 4, 10, 5, 6, 7, 8, 9")]
    pub rule: ::core::option::Option<permission::Rule>,
}
/// Nested message and enum types in `Permission`.
pub mod permission {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Set {
        #[prost(message, repeated, tag = "1")]
        pub rules: ::prost::alloc::vec::Vec<super::Permission>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Rule {
        #[prost(message, tag = "1")]
        AndRules(Set),
        #[prost(message, tag = "2")]
        OrRules(Set),
        #[prost(bool, tag = "3")]
        Any(bool),
        #[prost(message, tag = "4")]
        Header(super::super::super::super::api::v2::route::HeaderMatcher),
        #[prost(message, tag = "10")]
        UrlPath(super::super::super::super::r#type::matcher::PathMatcher),
        #[prost(message, tag = "5")]
        DestinationIp(super::super::super::super::api::v2::core::CidrRange),
        #[prost(uint32, tag = "6")]
        DestinationPort(u32),
        #[prost(message, tag = "7")]
        Metadata(super::super::super::super::r#type::matcher::MetadataMatcher),
        #[prost(message, tag = "8")]
        NotRule(::prost::alloc::boxed::Box<super::Permission>),
        #[prost(message, tag = "9")]
        RequestedServerName(super::super::super::super::r#type::matcher::StringMatcher),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Principal {
    #[prost(oneof = "principal::Identifier", tags = "1, 2, 3, 4, 5, 10, 11, 6, 9, 7, 8")]
    pub identifier: ::core::option::Option<principal::Identifier>,
}
/// Nested message and enum types in `Principal`.
pub mod principal {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Set {
        #[prost(message, repeated, tag = "1")]
        pub ids: ::prost::alloc::vec::Vec<super::Principal>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Authenticated {
        #[prost(message, optional, tag = "2")]
        pub principal_name: ::core::option::Option<
            super::super::super::super::r#type::matcher::StringMatcher,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Identifier {
        #[prost(message, tag = "1")]
        AndIds(Set),
        #[prost(message, tag = "2")]
        OrIds(Set),
        #[prost(bool, tag = "3")]
        Any(bool),
        #[prost(message, tag = "4")]
        Authenticated(Authenticated),
        #[prost(message, tag = "5")]
        SourceIp(super::super::super::super::api::v2::core::CidrRange),
        #[prost(message, tag = "10")]
        DirectRemoteIp(super::super::super::super::api::v2::core::CidrRange),
        #[prost(message, tag = "11")]
        RemoteIp(super::super::super::super::api::v2::core::CidrRange),
        #[prost(message, tag = "6")]
        Header(super::super::super::super::api::v2::route::HeaderMatcher),
        #[prost(message, tag = "9")]
        UrlPath(super::super::super::super::r#type::matcher::PathMatcher),
        #[prost(message, tag = "7")]
        Metadata(super::super::super::super::r#type::matcher::MetadataMatcher),
        #[prost(message, tag = "8")]
        NotId(::prost::alloc::boxed::Box<super::Principal>),
    }
}
