// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TlsParameters {
    #[prost(enumeration = "tls_parameters::TlsProtocol", tag = "1")]
    pub tls_minimum_protocol_version: i32,
    #[prost(enumeration = "tls_parameters::TlsProtocol", tag = "2")]
    pub tls_maximum_protocol_version: i32,
    #[prost(string, repeated, tag = "3")]
    pub cipher_suites: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub ecdh_curves: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `TlsParameters`.
pub mod tls_parameters {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TlsProtocol {
        TlsAuto = 0,
        TlSv10 = 1,
        TlSv11 = 2,
        TlSv12 = 3,
        TlSv13 = 4,
    }
    impl TlsProtocol {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TlsProtocol::TlsAuto => "TLS_AUTO",
                TlsProtocol::TlSv10 => "TLSv1_0",
                TlsProtocol::TlSv11 => "TLSv1_1",
                TlsProtocol::TlSv12 => "TLSv1_2",
                TlsProtocol::TlSv13 => "TLSv1_3",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TLS_AUTO" => Some(Self::TlsAuto),
                "TLSv1_0" => Some(Self::TlSv10),
                "TLSv1_1" => Some(Self::TlSv11),
                "TLSv1_2" => Some(Self::TlSv12),
                "TLSv1_3" => Some(Self::TlSv13),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateKeyProvider {
    #[prost(string, tag = "1")]
    pub provider_name: ::prost::alloc::string::String,
    #[prost(oneof = "private_key_provider::ConfigType", tags = "2, 3")]
    pub config_type: ::core::option::Option<private_key_provider::ConfigType>,
}
/// Nested message and enum types in `PrivateKeyProvider`.
pub mod private_key_provider {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConfigType {
        #[prost(message, tag = "2")]
        Config(super::super::super::super::super::google::protobuf::Struct),
        #[prost(message, tag = "3")]
        TypedConfig(super::super::super::super::super::google::protobuf::Any),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TlsCertificate {
    #[prost(message, optional, tag = "1")]
    pub certificate_chain: ::core::option::Option<super::core::DataSource>,
    #[prost(message, optional, tag = "2")]
    pub private_key: ::core::option::Option<super::core::DataSource>,
    #[prost(message, optional, tag = "6")]
    pub private_key_provider: ::core::option::Option<PrivateKeyProvider>,
    #[prost(message, optional, tag = "3")]
    pub password: ::core::option::Option<super::core::DataSource>,
    #[prost(message, optional, tag = "4")]
    pub ocsp_staple: ::core::option::Option<super::core::DataSource>,
    #[prost(message, repeated, tag = "5")]
    pub signed_certificate_timestamp: ::prost::alloc::vec::Vec<super::core::DataSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TlsSessionTicketKeys {
    #[prost(message, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<super::core::DataSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CertificateValidationContext {
    #[prost(message, optional, tag = "1")]
    pub trusted_ca: ::core::option::Option<super::core::DataSource>,
    #[prost(string, repeated, tag = "3")]
    pub verify_certificate_spki: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "2")]
    pub verify_certificate_hash: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[deprecated]
    #[prost(string, repeated, tag = "4")]
    pub verify_subject_alt_name: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "9")]
    pub match_subject_alt_names: ::prost::alloc::vec::Vec<
        super::super::super::r#type::matcher::StringMatcher,
    >,
    #[prost(message, optional, tag = "5")]
    pub require_ocsp_staple: ::core::option::Option<
        super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(message, optional, tag = "6")]
    pub require_signed_certificate_timestamp: ::core::option::Option<
        super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(message, optional, tag = "7")]
    pub crl: ::core::option::Option<super::core::DataSource>,
    #[prost(bool, tag = "8")]
    pub allow_expired_certificate: bool,
    #[prost(
        enumeration = "certificate_validation_context::TrustChainVerification",
        tag = "10"
    )]
    pub trust_chain_verification: i32,
}
/// Nested message and enum types in `CertificateValidationContext`.
pub mod certificate_validation_context {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TrustChainVerification {
        VerifyTrustChain = 0,
        AcceptUntrusted = 1,
    }
    impl TrustChainVerification {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TrustChainVerification::VerifyTrustChain => "VERIFY_TRUST_CHAIN",
                TrustChainVerification::AcceptUntrusted => "ACCEPT_UNTRUSTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VERIFY_TRUST_CHAIN" => Some(Self::VerifyTrustChain),
                "ACCEPT_UNTRUSTED" => Some(Self::AcceptUntrusted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenericSecret {
    #[prost(message, optional, tag = "1")]
    pub secret: ::core::option::Option<super::core::DataSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SdsSecretConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub sds_config: ::core::option::Option<super::core::ConfigSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Secret {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "secret::Type", tags = "2, 3, 4, 5")]
    pub r#type: ::core::option::Option<secret::Type>,
}
/// Nested message and enum types in `Secret`.
pub mod secret {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "2")]
        TlsCertificate(super::TlsCertificate),
        #[prost(message, tag = "3")]
        SessionTicketKeys(super::TlsSessionTicketKeys),
        #[prost(message, tag = "4")]
        ValidationContext(super::CertificateValidationContext),
        #[prost(message, tag = "5")]
        GenericSecret(super::GenericSecret),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpstreamTlsContext {
    #[prost(message, optional, tag = "1")]
    pub common_tls_context: ::core::option::Option<CommonTlsContext>,
    #[prost(string, tag = "2")]
    pub sni: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub allow_renegotiation: bool,
    #[prost(message, optional, tag = "4")]
    pub max_session_keys: ::core::option::Option<
        super::super::super::super::google::protobuf::UInt32Value,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownstreamTlsContext {
    #[prost(message, optional, tag = "1")]
    pub common_tls_context: ::core::option::Option<CommonTlsContext>,
    #[prost(message, optional, tag = "2")]
    pub require_client_certificate: ::core::option::Option<
        super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(message, optional, tag = "3")]
    pub require_sni: ::core::option::Option<
        super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(message, optional, tag = "6")]
    pub session_timeout: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(oneof = "downstream_tls_context::SessionTicketKeysType", tags = "4, 5, 7")]
    pub session_ticket_keys_type: ::core::option::Option<
        downstream_tls_context::SessionTicketKeysType,
    >,
}
/// Nested message and enum types in `DownstreamTlsContext`.
pub mod downstream_tls_context {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SessionTicketKeysType {
        #[prost(message, tag = "4")]
        SessionTicketKeys(super::TlsSessionTicketKeys),
        #[prost(message, tag = "5")]
        SessionTicketKeysSdsSecretConfig(super::SdsSecretConfig),
        #[prost(bool, tag = "7")]
        DisableStatelessSessionResumption(bool),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommonTlsContext {
    #[prost(message, optional, tag = "1")]
    pub tls_params: ::core::option::Option<TlsParameters>,
    #[prost(message, repeated, tag = "2")]
    pub tls_certificates: ::prost::alloc::vec::Vec<TlsCertificate>,
    #[prost(message, repeated, tag = "6")]
    pub tls_certificate_sds_secret_configs: ::prost::alloc::vec::Vec<SdsSecretConfig>,
    #[prost(string, repeated, tag = "4")]
    pub alpn_protocols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(oneof = "common_tls_context::ValidationContextType", tags = "3, 7, 8")]
    pub validation_context_type: ::core::option::Option<
        common_tls_context::ValidationContextType,
    >,
}
/// Nested message and enum types in `CommonTlsContext`.
pub mod common_tls_context {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CombinedCertificateValidationContext {
        #[prost(message, optional, tag = "1")]
        pub default_validation_context: ::core::option::Option<
            super::CertificateValidationContext,
        >,
        #[prost(message, optional, tag = "2")]
        pub validation_context_sds_secret_config: ::core::option::Option<
            super::SdsSecretConfig,
        >,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ValidationContextType {
        #[prost(message, tag = "3")]
        ValidationContext(super::CertificateValidationContext),
        #[prost(message, tag = "7")]
        ValidationContextSdsSecretConfig(super::SdsSecretConfig),
        #[prost(message, tag = "8")]
        CombinedValidationContext(CombinedCertificateValidationContext),
    }
}
