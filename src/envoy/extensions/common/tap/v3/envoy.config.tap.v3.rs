// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TapConfig {
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub match_config: ::core::option::Option<MatchPredicate>,
    #[prost(message, optional, tag = "4")]
    pub r#match: ::core::option::Option<
        super::super::common::matcher::v3::MatchPredicate,
    >,
    #[prost(message, optional, tag = "2")]
    pub output_config: ::core::option::Option<OutputConfig>,
    #[prost(message, optional, tag = "3")]
    pub tap_enabled: ::core::option::Option<
        super::super::core::v3::RuntimeFractionalPercent,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchPredicate {
    #[prost(oneof = "match_predicate::Rule", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
    pub rule: ::core::option::Option<match_predicate::Rule>,
}
/// Nested message and enum types in `MatchPredicate`.
pub mod match_predicate {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MatchSet {
        #[prost(message, repeated, tag = "1")]
        pub rules: ::prost::alloc::vec::Vec<super::MatchPredicate>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Rule {
        #[prost(message, tag = "1")]
        OrMatch(MatchSet),
        #[prost(message, tag = "2")]
        AndMatch(MatchSet),
        #[prost(message, tag = "3")]
        NotMatch(::prost::alloc::boxed::Box<super::MatchPredicate>),
        #[prost(bool, tag = "4")]
        AnyMatch(bool),
        #[prost(message, tag = "5")]
        HttpRequestHeadersMatch(super::HttpHeadersMatch),
        #[prost(message, tag = "6")]
        HttpRequestTrailersMatch(super::HttpHeadersMatch),
        #[prost(message, tag = "7")]
        HttpResponseHeadersMatch(super::HttpHeadersMatch),
        #[prost(message, tag = "8")]
        HttpResponseTrailersMatch(super::HttpHeadersMatch),
        #[prost(message, tag = "9")]
        HttpRequestGenericBodyMatch(super::HttpGenericBodyMatch),
        #[prost(message, tag = "10")]
        HttpResponseGenericBodyMatch(super::HttpGenericBodyMatch),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpHeadersMatch {
    #[prost(message, repeated, tag = "1")]
    pub headers: ::prost::alloc::vec::Vec<super::super::route::v3::HeaderMatcher>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpGenericBodyMatch {
    #[prost(uint32, tag = "1")]
    pub bytes_limit: u32,
    #[prost(message, repeated, tag = "2")]
    pub patterns: ::prost::alloc::vec::Vec<http_generic_body_match::GenericTextMatch>,
}
/// Nested message and enum types in `HttpGenericBodyMatch`.
pub mod http_generic_body_match {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GenericTextMatch {
        #[prost(oneof = "generic_text_match::Rule", tags = "1, 2")]
        pub rule: ::core::option::Option<generic_text_match::Rule>,
    }
    /// Nested message and enum types in `GenericTextMatch`.
    pub mod generic_text_match {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Rule {
            #[prost(string, tag = "1")]
            StringMatch(::prost::alloc::string::String),
            #[prost(bytes, tag = "2")]
            BinaryMatch(::prost::alloc::vec::Vec<u8>),
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputConfig {
    #[prost(message, repeated, tag = "1")]
    pub sinks: ::prost::alloc::vec::Vec<OutputSink>,
    #[prost(message, optional, tag = "2")]
    pub max_buffered_rx_bytes: ::core::option::Option<
        super::super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(message, optional, tag = "3")]
    pub max_buffered_tx_bytes: ::core::option::Option<
        super::super::super::super::google::protobuf::UInt32Value,
    >,
    #[prost(bool, tag = "4")]
    pub streaming: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputSink {
    #[prost(enumeration = "output_sink::Format", tag = "1")]
    pub format: i32,
    #[prost(oneof = "output_sink::OutputSinkType", tags = "2, 3, 4, 5, 6")]
    pub output_sink_type: ::core::option::Option<output_sink::OutputSinkType>,
}
/// Nested message and enum types in `OutputSink`.
pub mod output_sink {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Format {
        JsonBodyAsBytes = 0,
        JsonBodyAsString = 1,
        ProtoBinary = 2,
        ProtoBinaryLengthDelimited = 3,
        ProtoText = 4,
    }
    impl Format {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Format::JsonBodyAsBytes => "JSON_BODY_AS_BYTES",
                Format::JsonBodyAsString => "JSON_BODY_AS_STRING",
                Format::ProtoBinary => "PROTO_BINARY",
                Format::ProtoBinaryLengthDelimited => "PROTO_BINARY_LENGTH_DELIMITED",
                Format::ProtoText => "PROTO_TEXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "JSON_BODY_AS_BYTES" => Some(Self::JsonBodyAsBytes),
                "JSON_BODY_AS_STRING" => Some(Self::JsonBodyAsString),
                "PROTO_BINARY" => Some(Self::ProtoBinary),
                "PROTO_BINARY_LENGTH_DELIMITED" => Some(Self::ProtoBinaryLengthDelimited),
                "PROTO_TEXT" => Some(Self::ProtoText),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OutputSinkType {
        #[prost(message, tag = "2")]
        StreamingAdmin(super::StreamingAdminSink),
        #[prost(message, tag = "3")]
        FilePerTap(super::FilePerTapSink),
        #[prost(message, tag = "4")]
        StreamingGrpc(super::StreamingGrpcSink),
        #[prost(message, tag = "5")]
        BufferedAdmin(super::BufferedAdminSink),
        #[prost(message, tag = "6")]
        CustomSink(super::super::super::core::v3::TypedExtensionConfig),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StreamingAdminSink {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BufferedAdminSink {
    #[prost(uint64, tag = "1")]
    pub max_traces: u64,
    #[prost(message, optional, tag = "2")]
    pub timeout: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilePerTapSink {
    #[prost(string, tag = "1")]
    pub path_prefix: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingGrpcSink {
    #[prost(string, tag = "1")]
    pub tap_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub grpc_service: ::core::option::Option<super::super::core::v3::GrpcService>,
}
