// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsSink {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "stats_sink::ConfigType", tags = "3")]
    pub config_type: ::core::option::Option<stats_sink::ConfigType>,
}
/// Nested message and enum types in `StatsSink`.
pub mod stats_sink {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConfigType {
        #[prost(message, tag = "3")]
        TypedConfig(super::super::super::super::super::google::protobuf::Any),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsConfig {
    #[prost(message, repeated, tag = "1")]
    pub stats_tags: ::prost::alloc::vec::Vec<TagSpecifier>,
    #[prost(message, optional, tag = "2")]
    pub use_all_default_tags: ::core::option::Option<
        super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(message, optional, tag = "3")]
    pub stats_matcher: ::core::option::Option<StatsMatcher>,
    #[prost(message, repeated, tag = "4")]
    pub histogram_bucket_settings: ::prost::alloc::vec::Vec<HistogramBucketSettings>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsMatcher {
    #[prost(oneof = "stats_matcher::StatsMatcher", tags = "1, 2, 3")]
    pub stats_matcher: ::core::option::Option<stats_matcher::StatsMatcher>,
}
/// Nested message and enum types in `StatsMatcher`.
pub mod stats_matcher {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum StatsMatcher {
        #[prost(bool, tag = "1")]
        RejectAll(bool),
        #[prost(message, tag = "2")]
        ExclusionList(
            super::super::super::super::r#type::matcher::v3::ListStringMatcher,
        ),
        #[prost(message, tag = "3")]
        InclusionList(
            super::super::super::super::r#type::matcher::v3::ListStringMatcher,
        ),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TagSpecifier {
    #[prost(string, tag = "1")]
    pub tag_name: ::prost::alloc::string::String,
    #[prost(oneof = "tag_specifier::TagValue", tags = "2, 3")]
    pub tag_value: ::core::option::Option<tag_specifier::TagValue>,
}
/// Nested message and enum types in `TagSpecifier`.
pub mod tag_specifier {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TagValue {
        #[prost(string, tag = "2")]
        Regex(::prost::alloc::string::String),
        #[prost(string, tag = "3")]
        FixedValue(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistogramBucketSettings {
    #[prost(message, optional, tag = "1")]
    pub r#match: ::core::option::Option<
        super::super::super::r#type::matcher::v3::StringMatcher,
    >,
    #[prost(double, repeated, packed = "false", tag = "2")]
    pub buckets: ::prost::alloc::vec::Vec<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsdSink {
    #[prost(string, tag = "3")]
    pub prefix: ::prost::alloc::string::String,
    #[prost(oneof = "statsd_sink::StatsdSpecifier", tags = "1, 2")]
    pub statsd_specifier: ::core::option::Option<statsd_sink::StatsdSpecifier>,
}
/// Nested message and enum types in `StatsdSink`.
pub mod statsd_sink {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum StatsdSpecifier {
        #[prost(message, tag = "1")]
        Address(super::super::super::core::v3::Address),
        #[prost(string, tag = "2")]
        TcpClusterName(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DogStatsdSink {
    #[prost(string, tag = "3")]
    pub prefix: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub max_bytes_per_datagram: ::core::option::Option<
        super::super::super::super::google::protobuf::UInt64Value,
    >,
    #[prost(oneof = "dog_statsd_sink::DogStatsdSpecifier", tags = "1")]
    pub dog_statsd_specifier: ::core::option::Option<
        dog_statsd_sink::DogStatsdSpecifier,
    >,
}
/// Nested message and enum types in `DogStatsdSink`.
pub mod dog_statsd_sink {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DogStatsdSpecifier {
        #[prost(message, tag = "1")]
        Address(super::super::super::core::v3::Address),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HystrixSink {
    #[prost(int64, tag = "1")]
    pub num_buckets: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricsServiceConfig {
    #[prost(message, optional, tag = "1")]
    pub grpc_service: ::core::option::Option<super::super::core::v3::GrpcService>,
    #[prost(enumeration = "super::super::core::v3::ApiVersion", tag = "3")]
    pub transport_api_version: i32,
    #[prost(message, optional, tag = "2")]
    pub report_counters_as_deltas: ::core::option::Option<
        super::super::super::super::google::protobuf::BoolValue,
    >,
    #[prost(bool, tag = "4")]
    pub emit_tags_as_labels: bool,
    #[prost(enumeration = "HistogramEmitMode", tag = "5")]
    pub histogram_emit_mode: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HistogramEmitMode {
    SummaryAndHistogram = 0,
    Summary = 1,
    Histogram = 2,
}
impl HistogramEmitMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HistogramEmitMode::SummaryAndHistogram => "SUMMARY_AND_HISTOGRAM",
            HistogramEmitMode::Summary => "SUMMARY",
            HistogramEmitMode::Histogram => "HISTOGRAM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUMMARY_AND_HISTOGRAM" => Some(Self::SummaryAndHistogram),
            "SUMMARY" => Some(Self::Summary),
            "HISTOGRAM" => Some(Self::Histogram),
            _ => None,
        }
    }
}
