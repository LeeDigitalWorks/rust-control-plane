// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RateLimit {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub stage: u32,
    #[prost(string, tag = "3")]
    pub request_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub timeout: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(bool, tag = "5")]
    pub failure_mode_deny: bool,
    #[prost(bool, tag = "6")]
    pub rate_limited_as_resource_exhausted: bool,
    #[prost(message, optional, tag = "7")]
    pub rate_limit_service: ::core::option::Option<
        super::super::super::super::super::config::ratelimit::v3::RateLimitServiceConfig,
    >,
    #[prost(enumeration = "rate_limit::XRateLimitHeadersRfcVersion", tag = "8")]
    pub enable_x_ratelimit_headers: i32,
    #[prost(bool, tag = "9")]
    pub disable_x_envoy_ratelimited_header: bool,
    #[prost(message, optional, tag = "10")]
    pub rate_limited_status: ::core::option::Option<
        super::super::super::super::super::r#type::v3::HttpStatus,
    >,
    #[prost(message, repeated, tag = "11")]
    pub response_headers_to_add: ::prost::alloc::vec::Vec<
        super::super::super::super::super::config::core::v3::HeaderValueOption,
    >,
    #[prost(message, optional, tag = "12")]
    pub status_on_error: ::core::option::Option<
        super::super::super::super::super::r#type::v3::HttpStatus,
    >,
    #[prost(string, tag = "13")]
    pub stat_prefix: ::prost::alloc::string::String,
}
/// Nested message and enum types in `RateLimit`.
pub mod rate_limit {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum XRateLimitHeadersRfcVersion {
        Off = 0,
        DraftVersion03 = 1,
    }
    impl XRateLimitHeadersRfcVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                XRateLimitHeadersRfcVersion::Off => "OFF",
                XRateLimitHeadersRfcVersion::DraftVersion03 => "DRAFT_VERSION_03",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OFF" => Some(Self::Off),
                "DRAFT_VERSION_03" => Some(Self::DraftVersion03),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RateLimitConfig {
    #[prost(uint32, tag = "1")]
    pub stage: u32,
    #[prost(string, tag = "2")]
    pub disable_key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub actions: ::prost::alloc::vec::Vec<rate_limit_config::Action>,
    #[prost(message, optional, tag = "4")]
    pub limit: ::core::option::Option<rate_limit_config::Override>,
}
/// Nested message and enum types in `RateLimitConfig`.
pub mod rate_limit_config {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Action {
        #[prost(oneof = "action::ActionSpecifier", tags = "1, 2, 3, 4, 5, 6, 8, 9")]
        pub action_specifier: ::core::option::Option<action::ActionSpecifier>,
    }
    /// Nested message and enum types in `Action`.
    pub mod action {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct SourceCluster {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct DestinationCluster {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RequestHeaders {
            #[prost(string, tag = "1")]
            pub header_name: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub descriptor_key: ::prost::alloc::string::String,
            #[prost(bool, tag = "3")]
            pub skip_if_absent: bool,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct RemoteAddress {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct GenericKey {
            #[prost(string, tag = "1")]
            pub descriptor_value: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub descriptor_key: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct HeaderValueMatch {
            #[prost(string, tag = "1")]
            pub descriptor_value: ::prost::alloc::string::String,
            #[prost(bool, tag = "2")]
            pub expect_match: bool,
            #[prost(message, repeated, tag = "3")]
            pub headers: ::prost::alloc::vec::Vec<
                super::super::super::super::super::super::super::config::route::v3::HeaderMatcher,
            >,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MetaData {
            #[prost(string, tag = "1")]
            pub descriptor_key: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub metadata_key: ::core::option::Option<
                super::super::super::super::super::super::super::r#type::metadata::v3::MetadataKey,
            >,
            #[prost(string, tag = "3")]
            pub default_value: ::prost::alloc::string::String,
            #[prost(enumeration = "meta_data::Source", tag = "4")]
            pub source: i32,
            #[prost(bool, tag = "5")]
            pub skip_if_absent: bool,
        }
        /// Nested message and enum types in `MetaData`.
        pub mod meta_data {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Source {
                Dynamic = 0,
                RouteEntry = 1,
            }
            impl Source {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Source::Dynamic => "DYNAMIC",
                        Source::RouteEntry => "ROUTE_ENTRY",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "DYNAMIC" => Some(Self::Dynamic),
                        "ROUTE_ENTRY" => Some(Self::RouteEntry),
                        _ => None,
                    }
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ActionSpecifier {
            #[prost(message, tag = "1")]
            SourceCluster(SourceCluster),
            #[prost(message, tag = "2")]
            DestinationCluster(DestinationCluster),
            #[prost(message, tag = "3")]
            RequestHeaders(RequestHeaders),
            #[prost(message, tag = "4")]
            RemoteAddress(RemoteAddress),
            #[prost(message, tag = "5")]
            GenericKey(GenericKey),
            #[prost(message, tag = "6")]
            HeaderValueMatch(HeaderValueMatch),
            #[prost(message, tag = "8")]
            Metadata(MetaData),
            #[prost(message, tag = "9")]
            Extension(
                super::super::super::super::super::super::super::config::core::v3::TypedExtensionConfig,
            ),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Override {
        #[prost(oneof = "r#override::OverrideSpecifier", tags = "1")]
        pub override_specifier: ::core::option::Option<r#override::OverrideSpecifier>,
    }
    /// Nested message and enum types in `Override`.
    pub mod r#override {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DynamicMetadata {
            #[prost(message, optional, tag = "1")]
            pub metadata_key: ::core::option::Option<
                super::super::super::super::super::super::super::r#type::metadata::v3::MetadataKey,
            >,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum OverrideSpecifier {
            #[prost(message, tag = "1")]
            DynamicMetadata(DynamicMetadata),
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RateLimitPerRoute {
    #[prost(enumeration = "rate_limit_per_route::VhRateLimitsOptions", tag = "1")]
    pub vh_rate_limits: i32,
    #[prost(enumeration = "rate_limit_per_route::OverrideOptions", tag = "2")]
    pub override_option: i32,
    #[prost(message, repeated, tag = "3")]
    pub rate_limits: ::prost::alloc::vec::Vec<RateLimitConfig>,
    #[prost(string, tag = "4")]
    pub domain: ::prost::alloc::string::String,
}
/// Nested message and enum types in `RateLimitPerRoute`.
pub mod rate_limit_per_route {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VhRateLimitsOptions {
        Override = 0,
        Include = 1,
        Ignore = 2,
    }
    impl VhRateLimitsOptions {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                VhRateLimitsOptions::Override => "OVERRIDE",
                VhRateLimitsOptions::Include => "INCLUDE",
                VhRateLimitsOptions::Ignore => "IGNORE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OVERRIDE" => Some(Self::Override),
                "INCLUDE" => Some(Self::Include),
                "IGNORE" => Some(Self::Ignore),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OverrideOptions {
        Default = 0,
        OverridePolicy = 1,
        IncludePolicy = 2,
        IgnorePolicy = 3,
    }
    impl OverrideOptions {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OverrideOptions::Default => "DEFAULT",
                OverrideOptions::OverridePolicy => "OVERRIDE_POLICY",
                OverrideOptions::IncludePolicy => "INCLUDE_POLICY",
                OverrideOptions::IgnorePolicy => "IGNORE_POLICY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT" => Some(Self::Default),
                "OVERRIDE_POLICY" => Some(Self::OverridePolicy),
                "INCLUDE_POLICY" => Some(Self::IncludePolicy),
                "IGNORE_POLICY" => Some(Self::IgnorePolicy),
                _ => None,
            }
        }
    }
}
